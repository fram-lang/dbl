import List

data TestLogger E = {log : String ->[E] Unit}

let testLoggerH =
  handler TestLogger
    { log     = effect log / r => fn logs => r () (log :: logs) }
    return s => fn l => (s, l)
    finally c => c ([] : List String)
  end


let withLogs (f : {E, ~logger : TestLogger E, F, ~logger2 : TestLogger F} -> Unit ->[E, F] Unit) =
  handle ~logger2 with testLoggerH in
  handle ~logger with testLoggerH in f ()


data BT E = {flip : Unit ->[E] Bool, fail : {X} -> Unit ->[E] X}

#let btH =
#  handler BT
#    { flip = effect () / r => r True + r False
#    , fail = effect ()     => []
#    }
#  return c => [c] 
#  end

let btH =
  handler BT
    { flip = effect () / r =>
      match r True with
      | Some x => Some x
      | None   => r False
      end
    , fail = effect () => None
    }
    return c => Some c
  end

let rec select {E} (bt : BT E) n = 
  if n == 0 then
    0
  else if bt.flip () then
    n
  else
    select bt (n - 1)

let xs = handle bt with btH in select bt 10

let _ = printStrLn xs.show

let ys (bt : BT _) =
  let x = select bt 5 in
  let y = select bt 5 in
  if x + y == 6 then
    (x, y)
  else
    bt.fail ()

let xs = handle bt with btH in ys bt

let _ = printStrLn xs.show

