import open /Mutable

#let seq = handle ~bt with lazy in lazyTry ()


#let _ = printSeq seq


data RefP = RefP of {Ref : type -> type}

let RefP {Ref} = (extern dbl_abstrType : Unit -> RefP) ()

data LazyState A = Thunk of (Unit ->> A) | Done of A
data Lazy X = Lazy of Ref (LazyState X)

let lazy {type X} (f : Unit ->> X) = Lazy ((extern dbl_ref : LazyState X -> Ref (LazyState X)) (Thunk f)) : Lazy X
let force {X} (Lazy x : Lazy X) = 
  match (extern dbl_refGet) x : LazyState X with
  | Done x => x
  | Thunk f =>
    let v = f () in
    ((extern dbl_refSet) x (Done v) : Unit); v
  end

let thunk = lazy (fn _ => printStrLn "asds")


rec 
  data Seq A = Seq of (Lazy (Node A))
  data Node A = Nil | Cons of A, Seq A
end

let empty = Seq (lazy (fn _ => Nil))

let rec toSeq (xs) = 
  match xs with
  | x :: xs => Seq (lazy (fn _ => Cons x (toSeq xs)))
  | [] => empty
  end

let rec concat (Seq xs) (Seq ys : Seq _) =
  Seq (lazy (fn _ =>
    match force xs with
    | Cons x tl => Cons x (concat tl (Seq ys))
    | Nil => force ys
    end))



data BT E =
  { flip : Unit ->[E] Bool
  , fail : {type X} -> Unit ->> X
  }

let lazyH =
  handler
    BT { flip = effect _ / r => concat (r True) (r False)
       , fail = effect _     => empty }
    return x => Seq (lazy (fn _ => Cons x empty))
  end

let select {~bt : BT _} (n : Int) = 
  let rec iter x = 
    if n <= x then
      ~bt.fail ()
    else
      if (~bt.flip ()) then
        x
      else
        iter (x + 1)
  in
  iter 0

let p = 100

let lazyTry {~bt} () =
  let x = select p
  let y = select p in
  if x + y == p then
    (x * p +  y)
  else
    ~bt.fail ()

let rec printSeq (Seq f : Seq Int) = 
  match force f with
  | Cons x tl => (printStrLn x.toString; printSeq tl)
  | Nil => ()
  end

let seq = (handle ~bt with lazyH in lazyTry ())
let _ = printStrLn "start"
let _ = printSeq seq 

let rec map f (Seq xs) = Seq (lazy (fn _ => 
  match force xs with
  | Cons x tl => Cons (f x) (map f tl)
  | Nil => Nil
  end))

let rec concs (Seq xs) = Seq (lazy (fn _ =>
  match force xs with
  | Nil => Nil
  | Cons (Seq xs) xss =>
    match force xs with
    | Cons x xs => Cons x (concat xs (concs xss))
    | Nil => let Seq xs = concs xss in force xs
    end
  end))

let bind xs f = concs (map f xs)

let rec iter (n : Int) = Seq (lazy (fn _ => 
  if n >= p
    then Nil
    else Cons n (iter (n + 1))))

let (Seq xs) = bind (iter 0) (fn x => bind (iter 0) (fn y => if p == (x + y) then (Seq (lazy (fn _ => Cons (x * p + y) empty))) else empty))

let _ =printStrLn "start"
# let _ = printSeq (Seq xs)
