import open Lazy
import /List

# shift-reset addition to Bernardys M structure

data rec SList =
  # last elem
  | SF of Int
  # regular elem (normal + end)
  | SS of Int, Int, SList
  # tagged elem, containes `last` width
  | SL of Int, SList

# preserve invariant that there is exactly one SL in entire list

let rec mkStr (s : String) (l : Int) = 
  if l <= 0 then
    ""
  else
    s + mkStr s (l - 1)

let rec foldr1 {~__line__, ~__file__} f xs = match xs with
  | x :: y :: [] => f x y
  | x :: xs => f x (foldr1 f xs)
  | _ => runtimeError "foldr fail"
  end

method rec format (self : SList) =
  match self with
  | SF i => "SF \{i}"
  | SS i j tl => "SS \{i} \{j} (\{tl})"
  | SL i tl => "SL \{i} (\{tl})"
  end

method rec equal (s1 : SList) (s2 : SList) =
  match (s1, s2) with
  | SF v1, SF v2 => v1 == v2
  | SS i1 j1 s1, SS i2 j2 s2 => i1 == i2 && j1 == j2 && s1 == s2
  | SL i1 s1, SL i2 s2 => i1 == i2 && s1 == s2
  | _ => False
  end

data Width =
  { width  : SList
  , height : Int
  }

method format (self : Width) =
  "Width {width = \{self.width}, height = \{self.height}}"

method equal (w1 : Width) (w2 : Width) =
  w1.width == w2.width && w1.height == w2.height

let text s = Width {width=SL s (SF s), height=0}

method flush (Width {width, height}) =
  let rec dropL w = match w with
    | SS i j tl => SS i j (dropL tl)
    | SL _ tl => tl
    | SF i => impossible ()
    end in
  Width {width = SL 0 (dropL width), height = height + 1}

pub let (<>) {X : type, method combine : X -> X ->> X} (val : X) = val.combine

# (N, +, 0) oraz (N, max, 0) są monoidami więc nie będę istalować inta w tej klasie

let max (x : Int) (y : Int) =
  if x > y then x else y

# this is f'ed up and need to be verified, maxes are not enough, pluses needed
method combine (w1 : Width) (w2 : Width) =
  # let _ = printStrLn w1.format
  # let _ = printStrLn w2.format
  let height = w1.height + w2.height in

  let rec add w xs = match xs with
    | SL i tl => SL (i + w) (add w tl)
    | SF i => SF (i + w)
    | SS i j tl => SS (i + w) (j + w) tl 
    end in

  let rec combineWs (w1 : SList) (w2 : SList) = 
    # let _ = printStrLn w1.format
    # let _ = printStrLn w2.format in 
    match (w1, w2) with
    # regular elements
    | SF i, SF i' => SF (max i i')
    | SS i j w1, SS i' j' w2 => SS (max i i') (max j j') (combineWs w1 w2)
    | SF i, SS i' j' w2 => SS i' (max i j') w2    
    | SS i j w1, SF i'  => SS i  (max j i') w1    
    
    # right last
    | SF i,      SL l (SF i') => SL l (SF (max i i'))
    | SS i j w1, SL l (SF i') => SL l (SS i (max i' j) w1)
    | SF i,      SL l (SS i' j' w2) => SL l (SS i' (max i j') w2)
    | SS i j w1, SL l (SS i' j' w2) => SL l (SS (max i i') (max j j') (combineWs w1 w2))

    # left last and anything else
    | _ => impossible ()
    end in

  let rec copyTillL (w1 : SList) (w2 : SList) =
    match w1 with
    | SF _ => impossible ()
    | SS i j tl => SS i j (copyTillL tl w2)
    | SL w tl => combineWs tl (add w w2)
    end in
  
  Width {width = copyTillL w1.width w2.width, height}

method map mb f = match mb with
  | None => None
  | Some x => Some (f x)
  end

method reset (w : Width) =
  let rec iter (xs : SList) = match xs with
    | SF i => (i, None)
    | SL i tl => (fst (iter tl), Some i)
    | SS i j tl =>
      let tl = iter tl in
      let tot = max j (i + fst tl) in
      (tot, snd tl >.map (fn x => (i + x)))
    end in
  match iter w.width with
  | (x, Some y) => Width { width = SL y (SF x), height = w.height }
  | _ => impossible ()
  end

method seq {~__line__, ~__file__} (w1 : Width) (w2 : Width) =
  let rec checkAssumpions (sh : SList) = match sh with
    | SL _ tl => checkAssumpions tl
    | SF _ => ()
    | SS i j tl =>
      assert {msg="Elements cannot be put in sequence"} (j == 0);
      checkAssumpions tl
      end in
  let _ = checkAssumpions w1.width
  let _ = checkAssumpions w2.width

  let rec join s = match s with
    | SL x tl => join tl
    | SS i j tl => SS i j (join tl)
    | SF i => match w2.width with
      | SL l (SF i') => SL (l + i) (SF (i' + i))
      | SL l (SS i' j' tl) => SL (l + i) (SS (i' + i) 0 tl)
      | SS i' j' tl => SS (i' + i) 0 tl
      | _ => impossible ()
      end
    end in
  Width {height = max w1.height w2.height, width = join w1.width}

pub let ($$) 
  {type X, method combine : X -> X ->> X, method flush : X ->> X}
  (a : X) (b : X) = a.flush <> b 

pub let (<+>) {type X, method seq : X -> X ->> X} (val : X) = val.seq

method getAlign (w : Width) =
  let rec iter (w : SList) = 
    match w with
    | SL _ tl => iter tl
    | SS _ _ tl => let (x, y) = iter tl in (x + 1, y)
    | SF i => (0, i)
    end
  in iter w.width

method shift (Width {width, height}) =
  Width {width = SS 0 0 width, height}

# let _ = printStrLn ((text 10) >.shift).format
# let _ = printStrLn ((text 100)).format
# let _ = printStrLn ((text 100) <> text 50).format
# let _ = printStrLn ((text 100)>.flush <> text 50).format
# 
# let _ = assert (text 10 == text 10)

## Lazy

method combine {E : effect, type X, method combine : X -> X ->> X } (l1 : Lazy E X) (l2 : Lazy E X) = 
  lazy (fn () => l1.force <> l2.force)

method flush {E : effect, type X, method flush : X ->> X} (self : Lazy E X) =
  lazy (fn () => self.force.flush)

method shift {E : effect, type X, method shift : X ->> X} (self : Lazy E X) =
  lazy (fn () => self.force.shift)

## Pairs

method combine
  {type X, method combine : X -> X ->> X, type Y, method combine : Y -> Y ->> Y}
  ((x1, y1) : Pair X Y) ((x2, y2) : Pair X Y) = (x1 <> x2, y1 <> y2)

method flush {type X, method flush : X ->> X, type Y, method flush : Y ->> Y}
  ((x, y) : Pair X Y) = (x.flush, y.flush)

method shift {type X, method shift : X ->> X, type Y, method shift : Y ->> Y}
  ((x, y) : Pair X Y) = (x.shift, y.shift)

let lazyText n = lazy (fn _ => text n)

# let _ = printStrLn ((lazyText 100 >.shift )).format
# let _ = printStrLn ((lazyText 100 <+> lazyText 200 >.shift)).format


data rec L =
  | LCat of L, L
  | LFill of Int, L
  | LStr of String
  | LEmpty
  | LShift of L
  | LReset of SList, L
  | LAlign of Int, Int, L

data Line = {fill : L, str : L}

let emptyLine = Line {fill = LEmpty, str = LEmpty}

type Lines = List Line

method flush (lines : Lines) = lines + [emptyLine]

method shift (lines : Lines) =
  List.map (fn (Line {fill, str}) => Line {fill = LShift fill, str = LShift str}) lines

method reset (lines : Lines) slist = 
  List.map (fn (Line {fill, str}) => Line {fill = LReset slist fill, str = LReset slist str}) lines

method reset {E : effect} (self : Lazy E Lines) slist =
  lazy (fn () => self.force.reset slist)

method reset {E : effect}
  ((x, y) : Pair Width (Lazy E Lines)) = (x.reset, y.reset x.width)

method combine (xs : Lines) (ys : Lines) =
  let rec iter xs = match xs with
    | [] => ys
    | [Line {fill, str}] =>
      match ys with
      | [] => [Line {fill, str}]
      | Line {fill=fill', str=str'} :: ys =>
        Line {fill=LCat fill fill', str = LCat str str'}
          :: List.map (fn (y : Line) => Line{fill=LCat fill y.fill, str=LCat fill y.str}) ys
      end
    | x :: xs => x :: iter xs
    end in
  iter xs

method seq (xs : Lines) (ys : Lines) ((n, cst) : Pair Int Int) =
  let rec iter (xs : Lines) (ys : Lines) = match (xs, ys) with
    | (x :: xs, y :: ys) =>
      Line {fill = x.fill, str = LCat x.str (LAlign n cst y.str)} ::
        iter xs ys
    | [], ys => List.map
      (fn (Line {fill, str}) => Line {fill, str = LAlign n cst str})
      ys
    | xs, [] => xs
    end in
  iter xs ys

method seq {E} ((x1, y1) : Pair Width (Lazy E Lines)) ((x2, y2) : Pair Width (Lazy E Lines)) =
  (x1 <+> x2, lazy (fn () => y1.force.seq y2.force x1.getAlign))

type LineState = Pair (Pair (Pair Int (List Int)) Int) Int

data State E =
  { put : LineState ->[E] Unit
  , get : Unit ->[E] LineState }

let stateH (w : Int) =
  handler
    State
      { put = effect s / r => fn _ => r () s
      , get = effect _ / r => fn s => r s s }
      return x => fn _ => x
      finally c => c (0, [w], 0, 0)
  end

method move {E} (st : State E) (w : Int) = 
  let (p, sh, x, l) = st.get () in
  st.put (p + w, sh, x, l)

method getShift {E} (st : State E) =
  let (p, sh, x, l) = st.get () in
  match sh with
  | [] => runtimeError "Empty shift state"
  | s :: sh =>
    assert (p <= s);
    let diff = s - p in
    st.put (s, sh, x + 1, s);
    diff
  end

method putShifts {E} (st : State E) (sl : SList) =
  let (p, sh, _, _) = st.get () in
  let rec iter (p : Int) sl = match sl with
    | SL _ tl => iter p tl
    | SF i => [i + p]
    | SS i _ tl => i + p :: iter (i + p) tl
    end in
  st.put (p, iter p sl, 0, p)

method getAlignment {E} (st : State E) (n : Int) (cst : Int) =
  let (p, sh, x, l) = st.get () in
  if x == n then
   (let p' = cst + l in
    st.put (p', sh, x, l);
    p' - p)
  else
    match List.drop (n - x) sh with
    | [] => impossible ()
    | s :: sh =>
      let p' = l + cst in
      st.put (p', sh, n, s);
      printStrLn "\{p'} \{s}::\{sh}";
      p' - p
    end

let rec genL {~h : State _} (self : L) = match self with
  | LEmpty => ""
  | LStr str => ~h.move str.length; str
  | LShift tl =>
    let s = ~h.getShift in
    mkStr " " s + genL tl
  | LReset sl tl =>
    let stBackup = ~h.get () in
    ~h.putShifts sl;
    let res = genL tl in
    ~h.put stBackup;
    res
  | LFill i tl =>
      ~h.move i;
      mkStr " " i + genL tl
  | LCat l1 l2 => genL l1 + genL l2
  | LAlign n cst tl =>
    let s = ~h.getAlignment n cst in
    mkStr " " s + genL tl
  end

let unlines w (xs : Lines) =
  let strs = List.map (fn (x : Line) => handle ~h with stateH w in genL x.str) xs in
  let rec fold (xs : List String) = match xs with
    | [] => ""
    | x :: xs => x + "\n" + fold xs
    end in
  fold strs

method snd = snd
method fst = fst

let textL (str : String) =
  let l = str.length in
  (Width {width = SL l (SF l), height = 0}, lazy (fn _ => [Line {fill=LFill str.length LEmpty, str=LStr str}]))

# let doc = (text "abcdef" $$ text "ghi") <> (text "aaaaaaa" $$ text "ccc")

# let _ = printStrLn (doc.fst.format)
# let _ = printStrLn (unlines (doc.snd.force))

let paretoSelector
  {X : type}
  (poset : X -> X ->> Bool)
  (seq : List X) = 
    let rec iter (mins : List X) (seq : List X) =
      match seq with
      | [] => mins.rev
      | x :: seq =>
        match List.findIndex (fn y => poset y x) mins with
        | Some _ => iter mins seq
        | None => (iter (x :: mins) seq)
        end
      end in
    iter [] seq

let xs = (3, 10) :: (6, 2) :: (4, 12) :: []
let poset (x, y) (z, w) = ((x : Int) < z) && ((y : Int) < w)

# let _ = printStrLn (paretoSelector poset xs).format

# true wybiera pierwszy
let rec mergeOn sel (xs : List _) (ys : List _) =
  match xs with
  | [] => ys
  | x :: xs' => match ys with
    | [] => xs
    | y :: ys' =>
      if sel x y then
        x :: mergeOn sel xs' ys
      else
        y :: mergeOn sel xs ys'
    end
  end

let rec mergeAllOn sel (xss : List _) = match xss with
  | [] => []
  | x :: ys => mergeOn sel x (mergeAllOn sel ys)
  end

let bestOn ord poset xss =
  paretoSelector poset (mergeAllOn ord xss)

let poset (w1 : Width) (w2 : Width) =
  match w1.reset, w2.reset with
  | Width {height=h1, width=SL l1 (SF m1)}
  , Width {height=h2, width=SL l2 (SF m2)}
    => m1 < m2 && h1 < h2 && l1 < l2
  | _ => impossible ()
  end 

let ord (w1 : Width) (w2 : Width) =
  match w1.reset, w2.reset with
  | Width {height=h1, width=SL l1 (SF m1)}
  , Width {height=h2, width=SL l2 (SF m2)}
    => h1 < h2 || (h1 == h2 && (m1 < m2 || (m1 == m2 && l1 < l2)))
  | _ => impossible ()
  end

let quasifilter (w : Int) (f : _ -> Width) (ws : List _) =
  match ws with
  | [] => [] #impossible ()
  | [x] => [x]
  | xs =>
    let maxWidth (w : Width) =
      match w.reset with
      | Width {width=SL _ (SF i)} => i
      | _ => impossible ()
      end in

    match List.filter (fn x => maxWidth (f x) <= w) (xs) with
    | [] =>
      let el = foldr1
      (fn x y =>
        if maxWidth (f x) <= maxWidth (f y) then x else y)
      xs in [el]
    | xs => xs
    end
  end

let discardInvalid w = quasifilter w (fst)

abstr data ODoc E =
  ODoc of (Int ->> List (Pair Width (Lazy E Lines)))

let (>>=) (xs : List _) f = xs.concatMap f

pub method combine (ODoc xs) (ODoc ys) = ODoc (fn w =>
  let ds = xs w >>= (fn x => [discardInvalid w (ys w >>= (fn y => [x <> y]))]) in
    bestOn
      (fn x y => ord (fst x) (fst y))
      (fn x y => poset (fst x) (fst y))
        ds)

pub method flush (ODoc xs) = ODoc (fn w => 
  (List.map (fn (w : Pair Width (Lazy _ Lines)) => w.flush) (xs w)))

pub let text str = ODoc (fn _ => [textL str])

pub let try w (ODoc xs) = match xs w with
  | [] => printStrLn "Error"
  #| (w, lines) :: _ =>
  #  printStrLn w.format;
  #  printStrLn (unlines lines.force)
  | xs =>
    let xs = discardInvalid w xs in
    List.iter (fn ((wd : Width), (lines : Lazy _ Lines)) =>
      printStrLn wd.format; printStrLn (unlines w lines.force)) xs
  end


# let _ = try 60
#   ((text "aaaaaaaaa" $$ text "aaaa") <> (text "bbbbbbbbbbb" $$ text "bbb"))

let empty = text ""

let rec initTail xs = match xs with
  | [] => impossible ()
  | [x] => ([], x)
  | x :: xs =>
    let (xs, e) = initTail xs in
    (x :: xs, e)
  end

let onlySingleLine = List.takeWhile (fn (Width {height}, _) => height == 0)

let spaces n =
  let rec iter n =
    if 0 >= n then "" else " " + iter (n - 1) in
  (Width {height = 0, width = (SL n (SF n))}, lazy (fn _ => [Line {fill = LFill n LEmpty, str = LStr (iter n)}]))

pub let groupingBy {E} (sep : String) (ms : List (Pair Int (ODoc E))) = 
  match ms with
  | [] => empty
  | ms => ODoc (fn w =>
    let mws = List.map (fn (x, ODoc d) => (x, d w)) ms in
    let (init, (_, last)) = initTail mws in
    let (hcat : List (List (Pair Width (Lazy E Lines))))
      = List.map (fn x => onlySingleLine (snd x)) init + [last] in
    let (vcat : List (List (Pair Width (Lazy E Lines))))
      = List.map (fn (i, x) => List.map (fn x => spaces i <> x) x) mws in
    let hor = discardInvalid w
      (foldr1
        (fn xs ys => xs >>= (fn x =>
                     ys >>= (fn y =>
                     [x <> textL sep <> y])))
        hcat) in
    let ver =
      foldr1
        (fn xs ys =>
          bestOn 
            (fn x y => ord (fst x) (fst y))
            (fn x y => poset (fst x) (fst y))
            (xs >>= (fn x =>
            [(ys >>= (fn y =>
               [x $$ y]))])))
        vcat in
    let ls = bestOn
      (fn x y => ord (fst x) (fst y))
      (fn x y => poset (fst x) (fst y))
      [hor, ver] in
    ls) # discardInvalid w ls) # ????? tego wywołania nie powinno tutaj być
  end

let hangWith sep n x y = groupingBy sep [(0, x), (n, y)]

let hanging = hangWith " " 2

pub method shift (ODoc xs) = ODoc (fn w =>
  List.map (fn (x : Pair Width (Lazy _ Lines)) => x.shift) (xs w))

pub method reset (ODoc xs) = ODoc (fn w =>
  List.map (fn (x : Pair Width (Lazy _ Lines)) => x.reset) (xs w))

pub method seq (ODoc xs) (ODoc ys) = ODoc (fn w =>
  xs w >>= (fn x =>
  ys w >>= (fn y =>
    [x <+> y])))

#let doc = hanging (text "aaaaaaaaa") (text "bbbbbbbbb")
#
#let _ = try 40 (doc $$ text "ccc") # (text "a" <> text "b")

let doc1 = (text "aaaaa" <> (text "bb" >. shift)) >. reset
let doc2 = (text "aaa" <> (text "bbbb" >. shift)) >. reset

#let _ = try 40 doc1
#let _ = try 40 doc2
#let doc =
#  ((text "aaaaa" <> (text "bb" >. shift) <> (text "cc" >. shift)) $$
#    (text "dddddddddddddddddddddddddddddddddddd") $$
#    (text "aaa" <> (text "bbbb" >. shift) <> (text "cc" >. shift)))

method rec format (l : L) = match l with
  | LEmpty => "e"
  | LCat l1 l2 => l1.format + " " + l2.format
  | LStr s => s.format
  | LFill n tl => n.format + " " + tl.format
  | LReset sl l => "reset " + sl.format + " " + l.format
  | LShift l => "shift " + l.format
  | LAlign x y l => "(align \{x} \{y}) \{l}"
  end

method format {?fmt : Unit} (l : Line) =
  "fill = \{l.fill}, str = \{l.str}"

pub let tryDebug w (ODoc xs) = match xs w with
  | [] => printStrLn "Error"
  #| (w, lines) :: _ =>
  #  printStrLn w.format;
  #  printStrLn (unlines lines.force)
  | xs =>
    let xs = discardInvalid w xs in
    List.iter (fn ((wd : Width), (lines : Lazy _ Lines)) =>
      List.iter (fn (l : Line) => printStrLn l.format) lines.force;
      printStrLn wd.format; printStrLn (unlines w lines.force)) xs
  end

#let _ = try 100 (groupingBy " " [(0, text "abracadbra"), (2, doc)]).reset

# let i = (groupingBy "" [(0, text "\"interp\\{"),
#                   (2, text 10.format),
#                   (0, text "} and \\{"),
#                   (2, text 20.format),
#                   (0, text "}\"")])
# 
# let _ = try 70 (i <> text " + " <> i)
  
