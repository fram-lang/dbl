data State E X = State of
  { get    : Unit ->[E] X
  , put    : X ->[E] Unit
  , update : {F} -> (X ->[E,F] X) ->[E,F] Unit
  }

{# We declare implicit parameter named `~st`. Now, the following function may
  use `~st` as a regular variable. In such a case, `~st` together with the
  associated effect E_st will be implicitly generalized. #}
parameter E_st
parameter ~st : State E_st _

{# We define get operation that works on implicit capability `~st`. It can be
  used in any context, where a variable named ~st is available (or can be
  implicitly generalized). We also define similar put and update functions. #}
let get x =
  let (State { get }) = ~st in
  get x

let put x =
  let (State { put }) = ~st in
  put x

let update f =
  let (State { update }) = ~st in
  update f

{# Now, we put the standard handler for state, that will become the state of the
  scheduler. Note that an expression that provides capability `~st` is not just
  a value, but more complex series of let-expressions. First, we define
  standard get and put operations, and then on top of them we define the update
  function. All three functions becomes part of the interface. #}
handle ~st =
  let get = effect x / r => fn s => r s  s
  let put = effect s / r => fn _ => r () s
  let update f = put (f (get ())) in
    State { get, put, update }
  return  x => fn _ => x
  finally c => c []
