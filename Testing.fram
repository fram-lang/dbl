import Map
import Mutable as M
import String as S
import List

let Map {module SMap} = Map.make {Key=String}

let sanitizeFileName {~__file__ = file} () =
  # clear realative path
  let file =
    if (file : String).get 0 == '.' then
      file.substring 2 (file.length)
    else
      file in
  # clear extension
  match S.findChar file '.' with
  | None => file
  | Some idx => file.substring 0 idx
  end

data Loc = {file : String, line : Int}

let mkLoc {~__line__ = line, ~__file__ = file} = Loc {line, file}

method toString (Loc {file, line}) = "\{file}:\{line}"

data TestResult = TR_Accept | TR_Reject

data TestCaseTracker E =
  { hardFail  : {X} -> Unit ->[E] X
  , softFail  : Unit ->[E] Unit
  , acceptAll : {X} -> Unit ->[E] X
  }

let testCaseTrackerH =
  handler TestCaseTracker
    { softFail  = effect _ / r => fn _ => r () TR_Reject
    , hardFail  = effect _     => fn _ => TR_Reject
    , acceptAll = effect _     => fn _ => TR_Accept
    }
    return _ => id
    finally c => c TR_Accept
  end

data LogType =
  | LT_Accept
  | LT_Fail
  | LT_Expect
  | LT_UserInfo

data LogMessage =
  { logType : LogType
  , message : String
  , loc     : Loc
  }

let mkLogMsg {~__line__, ~__file__} logType message = LogMessage {loc = mkLoc, message, logType}

data TestLogger E = {log : LogMessage ->[E] Unit, getLogs : Unit ->[E] List LogMessage}

let testLoggerH =
  handler TestLogger
    { log     = effect log / r => fn logs => r () (log :: logs)
    , getLogs = effect _ / r   => fn logs => r (logs) logs }
    return s => fn logs => (s, List.rev logs)
    finally c => c ([] : List LogMessage)
  end

data TestCase =
  { name : String
  , loc  : Loc
  , body : Unit ->[] Pair TestResult (List LogMessage)
  }

data TestLogs  =
  { testCase : TestCase
  , result   : TestResult
  , logs     : List LogMessage
  }

let printLogs (logs : TestLogs) (idx : Int) =
  printStrLn "\{idx} \{logs.testCase.name} \{logs.testCase.loc}";
  logs.logs.iter (fn (log : LogMessage) => printStrLn log.message)

data SessionLogger E = {reportTest : TestLogs ->[E] Int}

let sessionLoggerH =
  handler SessionLogger
    { reportTest = effect log / r => fn (id, logs) => r id (1 + id, (id, log) :: logs)}
    return s => fn (_, logs) => (s, List.rev logs)
    finally c => c (1, [])
  end

data SessionTestCounter E = {countTest : TestResult ->[E] Unit}

let sessionTestCounterH =
  handler SessionTestCounter
    { countTest = effect tr / r => fn (acc, fail) =>
        match tr with
        | TR_Accept => r () (acc + 1, fail)
        | TR_Reject => r () (acc, fail + 1)
        end
    }
    return _ => id
    finally c => c (0, 0)
  end

type NestedCase = Pair String TestCase

data rec TestTree = {tests : List NestedCase, suites : SMap.T TestTree}
let emptyTestTree = TestTree {tests=[], suites=SMap.empty}

method addTest (tree : TestTree) (test : TestCase) =
  let (path, name) = test.name.splitOn '/' >.dropTakeLast >.unwrap in
  let rec visit (TestTree {tests, suites}) path =
    match path with
    | [] => TestTree {tests = (name, test) :: tests, suites}
    | ns :: path =>
      let sub = suites.find ns >.unwrapOr emptyTestTree in
      TestTree {tests, suites = suites.add ns (visit sub path)}
    end
  in
  visit tree path

let constructTestTree (tests : List TestCase) = 
  tests.foldRight (fn test (tree : TestTree) => tree.addTest test) emptyTestTree

method iter (tree : TestTree) (f : {nesting : Int} -> Either String NestedCase ->> Unit) =
  let rec iter (tree : TestTree) (nesting : Int) =
    let nesting = nesting + 1 in
    tree.tests.rev.iter (fn tc => f {nesting} (Right tc));
    tree.suites.iter (fn {key} suite => f {nesting} (Left key); iter suite nesting)
  in
  iter tree 0

let printTree (tree : TestTree) =
  tree.iter (fn {nesting} case =>
    printStr (replicate "  " nesting);
    match case with
    | Left name => printStrLn name
    | Right (name, _) => printStrLn "+ \{name}"
    end)

let tests = M.ioMut.ref ([] : List TestCase)

pub let testCase
  {~__file__, ~__line__}
  (name : String)
  (f : {E_TL, E_TT, ~testLogger : TestLogger E_TL, ~testCaseTracker : TestCaseTracker E_TT} -> Unit ->[E_TL, E_TT] Unit) =
    let name    = "\{sanitizeFileName ()}/\{name}"
    let loc     = mkLoc
    let body () = 
      handle ~testLogger / E_TL with testLoggerH in
      handle ~testCaseTracker / E_TT with testCaseTrackerH in
        f {E_TL, E_TT} () 
    let tc = TestCase {name, loc, body}
    in
    tests := (tc :: tests.get)

let runTest {E_SL, ~sessionLogger : SessionLogger E_SL, E_ST, ~sessionTestCounter : SessionTestCounter E_ST}
  (tc : TestCase) =
    let TestCase {loc, name, body} = tc in
    # printStrLn "\{name} :: \{loc}";
    let (result, logs) = body () in
    let logNum = 
      match result with
      | TR_Reject => Some (~sessionLogger.reportTest (TestLogs {testCase=tc, logs, result}))
      | TR_Accept => None
      end
    in
    ~sessionTestCounter.countTest result

pub let runTests () =
  let tests = tests.get.rev in
  let tree = constructTestTree tests in
  let ((succ, fail), logs) =
    handle ~sessionLogger / E_SL with sessionLoggerH in
    handle ~sessionTestCounter / E_ST with sessionTestCounterH in
      tree.iter (fn {nesting} node =>
        printStr (replicate "  " nesting);
        match node with
        | Left ns => printStrLn ns
        | Right (name, test) =>
          printStrLn name;
          runTest {E_SL, E_ST} test
        end)
  in
  logs.iter (fn (idx, logs) => printLogs logs idx);
  printStrLn "\{succ}/\{fail + succ}"

section
  parameter ~testCaseTracker : TestCaseTracker _
  parameter ~testLogger : TestLogger _

  let log {~__line__, ~__file__} lt msg = ~testLogger.log (mkLogMsg lt msg)

  let hardFail () = ~testCaseTracker.hardFail ()
  let softFail () = ~testCaseTracker.softFail ()

  pub let assertTrue
      {~__line__, ~__file__, ?msg : String}
      cond =
    if not cond then
     (let message = msg.unwrapOr "Assertion Failed: Expected to be true" in
      log LT_Fail message;
      softFail ())
end
