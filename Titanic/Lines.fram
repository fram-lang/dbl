import /List

import open Types

pub method concat = LConc

pub let rec linesFill (f1 : Line) (ls1 : List Line) (f2 : Line) (ls2 : List Line) =
  match ls1, ls2 with
  | [],        []        => []
  | l1 :: ls1, []        => l1.concat f2 :: linesFill f1 ls1 f2 ls2
  | [],        l2 :: ls2 => f1.concat l2 :: linesFill f1 ls1 f2 ls2
  | l1 :: ls1, l2 :: ls2 => l1.concat l2 :: linesFill f1 ls1 f2 ls2
  end

data Flat =
  | FPop
  | FPush of Color
  | FChr  of Char

let rec flatLine (line : Line) tail =
  match line with
  | LStr str => List.map FChr str.toList + tail
  | LChr chr => FChr chr :: tail
  | LConc l1 l2 => flatLine l1 (flatLine l2 tail)
  | LFill n s =>
    let str = List.map FChr s.toList
    let rec repeat (n : Int) = 
      if n <= 0 
        then tail
        else str.append (repeat (n - 1))
    in repeat n
  | LEmpty => tail
  | LColor c => FPush c :: tail
  | LColorPop => FPop :: tail
  end

let flatToString cs = 
  let rec iter cs = 
    match cs with
    | FChr x :: tl => x :: iter tl
    | _ :: tl => iter tl
    | [] => []
    end
  in (charListToStr (iter cs)) : String

pub let reduceLines lines = 
  let flats = List.map (fn (l : Line) => flatToString (flatLine (l.concat (LChr '\n')) [])) lines
  in List.foldRight (fn l (r : String) => r + l) (flats : List String) ""
