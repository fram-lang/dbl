import /List

import open Width

rec
  pub data Doc = { tree : DocTree, width : Width }

  pub let doc tree width = Doc { tree, width }

  pub data DocTree =
    | DEmpty
    | DStr    of String
    | DShift  of Doc
    | DReset  of Doc
    | DSeq    of List Doc
    | DStack  of List Doc
    | DLayout of Int, Doc
    | DColor  of Color, Doc
    | DBox    of Doc
    | DFlex   of Int
    | DMon    of Doc, Doc
    | DExtra  of {type X}, String, X, (Int -> X ->> CtxBox)

  pub data CtxBox = { lines : List LineC
                    , fill  : LineC 
                    , size  : Int 
                    }

  pub let ctxBox lines fill size = CtxBox { lines, fill, size }

  pub let qCtx lines len = ctxBox lines (LineC {width=len, line=LFill len " " LEmp}) len

  pub data Color =
    | Black
    | Red
    | Green
    | Yellow
    | Blue
    | Magenta
    | Cyan
    | White

  pub data Line =
    | LEmp      # empty
    | LStr      of String, Line
    | LChr      of Char, Line
    | LCat      of Line, Line
    | LCatFill  of Line, Int, Line
    | LFill     of Int,  String, Line
    | LColor    of Color, Line
    | LColorPop of Line

  # Separate box width from individual line length
  # Idea borrowed from Bernardy's work
  pub data LineC = { width : Int, line : Line }
  pub let lineC width line = LineC {width, line}

  pub method cat (LineC {width=w1, line=l1}) (LineC {width=w2, line=l2}) =
    LineC {width = w1 + w2, line = LCat l1 l2}
  
  pub method catIndent (LineC {width=w1, line=l1}) indent (LineC {width=w2, line=l2}) =
    if w1 < indent then
      LineC {width = indent + w2, line = LCatFill l1 (indent - w1) l2}
    else
      LineC {width = w1 + w2, line = LCat l1 l2}

  pub method toString (c : Color) = 
    match c with
    | Black => "Black"
    | Red   => "Red"
    | Green => "Green"
    | Yellow => "Yellow"
    | Blue  => "Blue"
    | Magenta => "Magenta"
    | Cyan  => "Cyan"
    | White => "White"
    end

  pub method toString (d : Doc) = 
    "(" + d.width.toString + " -> " + d.tree.toString + ")"

  pub method toString (dt : DocTree) = 
    match dt with
    | DEmpty => "Empty"
    | DStr str => "Str " + str
    | DShift doc => "&" + doc.toString
    | DReset doc => "*" + doc.toString
    | DSeq ds => "Seq " + List.foldRight (fn (e : Doc) a => e.toString + " " + a) ds ""
    | DStack ds => "Stack " + List.foldRight (fn (e : Doc) a => e.toString + " " + a) ds ""
    | DLayout n doc => "Layout " + n.toString + " " + doc.toString
    | DFlex n => "Flex " + n.toString
    | DBox d => "Box " + d.toString
    | _ => "?"
    end

  pub method toString {type X, method toString : X ->> String} (self : List X) =
    "[" + List.foldRight (fn (e : X) a => e.toString + ", " + a) self "" + "]"
  
  pub data SValue =
    | SStr   of String
    | SInt   of Int
    | SColor of Color
  
  pub data ArgDict    = { args : List (Pair String SValue) }
  pub data CoreStyle  = { name : String, args : ArgDict, interp : List CoreInterp}
  pub data CoreInterp = { num : Int, style : CoreStyle }

  pub method toString (s : SValue) =
    match s with
    | SStr str => "'" + str + "'"
    | SInt i   => i.toString
    | SColor c => c.toString
    end

  pub method toString (s : ArgDict) = 
    "{" + List.foldRight (fn ((x, y) : Pair String SValue) acc => x + ":" + y.toString + ", " + acc) s.args "}"

  pub method toString (s : CoreStyle) =
    "(" + s.name + " " + s.args.toString + " " + s.interp.toString + ")"
  
  pub method toString (s : CoreInterp) =
    "(" + s.num.toString + " " + s.style.toString + ")"
end
