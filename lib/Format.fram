{# This file is part of DBL, released under MIT license.
 # See LICENSE for details.
 #}

pub method format (self : Unit) (fmt : Option String) = "()"

pub method format (self : Bool) (fmt : Option String) = self.toString

pub method format (self : Char) (fmt : Option String) = 
  "'" + self.toString + "'"

pub method format (self : Int) (fmt : Option String) = 
  let toBase (val : Int) (base : Int) =
    let rec iter (val : Int) (base : Int) (tail : List Char) =
      if val == 0 then
        tail
      else 
        (let (digit : Int) = val % base
        let (shift : Int) = val / base
        let ~onError = fn _ => '0'
        let code = if digit < 10 then
          chr ('0'.code + digit)
        else
          chr ('A'.code + digit - 10)
        in iter shift base (code :: tail)) in
    charListToStr (iter val base []) in
  let fmt = fmt.unwrapOr "d" in
  if fmt == "x" then
    "0x" +toBase self 16
  else if fmt == "d" then
    self.toString
  else if fmt == "o" then
    "0" + toBase self 8
  else if fmt == "b" then
    "0b" + toBase self 2
  else
    "Unkown int format: " + fmt

pub method format (self : String) (fmt : Option String) = self

pub method format 
  {type A, method format : A -> Option String ->[] String}
  (self : Option A) 
  (fmt : Option String) = 
  match self with
  | Some x => "Some " + x.format fmt
  | None   => "None"
  end

pub method format 
  {type A, method format : A -> Option String ->[] String}
  (self : List A)
  (fmt : Option String) =
  let rec iter (xs : List A) = 
    match xs with
    | []      => "]"
    | [x]     => x.format fmt + "]"
    | x :: xs => x.format fmt + ", " + iter xs
    end 
  in "[" + iter self
