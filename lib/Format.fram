import /List

## # Format methods

{##
  This module provides more advanced format methods.
  
  Each type has an associated data type that carries additional formatting
  options. Those structures may contain a nested format for subtypes.

  Default formatting should produce syntactically correct Fram expression.
  This constraint requires format methods to respect the operator and function
  application precedence and insert parenthesis if needed. It is handled by
  passing a precedence index of parent node. Application precedence strength
  defaults to 10. Parentheses might be disabled.
 ##}

# Handles parenthesis insertion
let addParenths
  (str : String)
  (precedence : Int)
  (parent : Option Int)
  (addParents : Option Bool) =
    if addParents.unwrapOr True then
     (let parent = parent.unwrapOr 0 in
      if precedence <= parent then
        "(" + str + ")"
      else
        str)
    else
      str

# Handles padding options
let padding 
  (str : String) 
  (size : Option Int) 
  (fill : Option Char) 
  (alignLeft : Option Bool) =

    let size = size.unwrapOr 0
    let fill = fill.unwrapOr ' '
    let alignLeft = alignLeft.unwrapOr False

    let _  = assert {msg="Negative padding"} (size >= 0)

    let df = size - str.length
    let df = if df < 0 then 0 else df
    let rec padding df = 
      if 0 == df then
        []
      else
        fill :: padding (df - 1)
    let padding = charListToStr (padding df) in
    if alignLeft then
      str + padding
    else
      padding + str

# Concatenates all strings in not particullary optimal fashion
# TODO: delete this function once interpolation is implemented
let rec strListCat (xs : List String) =
  match xs with
  | [] => ""
  | x :: xs => x + strListCat xs
  end

parameter X
parameter XFmt

parameter Y
parameter YFmt

## ## Unit

{## Unit format options ##}
pub data UnitFmt =
  {##
    Unit format options

    @param ?unit Overrides constructor name.
    @param ?size Total size to occupy.
    @param ?fill Padding fill character.
    @param ?alignLeft Padding direction.
   ##}
  UnitFmt of { ?unit : String
             , ?size : Int
             , ?fill : Char
             , ?alignLeft : Bool }

{##
  Unit format method.

  @param ?prec Parent precedence.
  @param ?fmt Format options.
 ##}
pub method format {?prec : Int, ?fmt : UnitFmt} () =
  let UnitFmt {unit, size, fill, alignLeft} = fmt.unwrapOr UnitFmt in
  let ctor = unit.unwrapOr "()" in
  padding ctor size fill alignLeft

## # Int

{## Int format options ##}
pub data IntFmt =
  {##
    Int format options.

    @param ?base Number base. Function accepts bases from 2 to 36.
    @param ?prefix Prefix, by default empty.
    @param ?size Total size.
    @param ?fill Padding fill charcter.
    @param ?alignLeft Padding direction.
    @param ?parenths Inserts parenthesis when minus sign is added.
   ##}
  IntFmt of { ?base : Int
            , ?prefix : String 
            , ?size : Int
            , ?fill : Char
            , ?alignLeft : Bool
            , ?parenths : Bool }

pub method format {?prec : Int, ?fmt : IntFmt} (self : Int) =
  let IntFmt {base, prefix, parenths} = fmt.unwrapOr IntFmt
  let IntFmt {size, fill, alignLeft}  = fmt.unwrapOr IntFmt
  let base = base.unwrapOr 10
  let prefix = prefix.unwrapOr ""
  let _ = assert {msg="Int base out of bounds"} (2 <= base && base <= 36)
  # handles negative number in base 10
  let (self, prefix, neg) = 
    if base == 10 && self < 0 then
      (-self, prefix + "-", True)
    else
      (self, prefix, False)
  # constructs representation
  let rec iter (n : Int) acc = 
    if n == 0 then
      acc
    else
     (let digit = n % base
      let shift = n / base
      let ~onError = fn _ => ' '
      let c = 
        if digit <= 9 then
          chr ('0'.code + digit)
        else 
          chr ('A'.code + digit - 10)
      in iter shift (c :: acc))
  # final result
  let num = prefix + charListToStr (iter self [])
  let parenths = Some (neg && (parenths.unwrapOr True))
  let num = addParenths num 150 prec parenths in
  padding num size fill alignLeft

## ## Char

{## Char format options. ##}
pub data CharFmt = 
  {##
    Char format options.

    @param ?escape Escapes Chars. Defaults to True.
    @param ?asInt Converts char to int and formats as such.
    @param ?size Total size.
    @param ?fill Padding fill size.
    @param ?alignLeft Padding direction.
   ##}
  CharFmt of { ?escape : Bool
             , ?asInt : IntFmt
             , ?size : Int
             , ?fill : Char
             , ?alignLeft : Bool }

let specialReprs =
  [ ('\"', "\\\"")
  , ('\'', "'"  )
  , ('\0', "\\0")
  , ('\n', "\\n")
  , ('\b', "\\b")
  , ('\t', "\\t")
  , ('\r', "\\r")
  , ('\v', "\\v")
  , ('\a', "\\a")
  , ('\f', "\\f")
  ]

## Converts a character to it's representation withous enquoting.
pub let charRepr (x : Char) = 
  let matchEsc (chr, repr) = 
    if x == chr then Some repr else None in
  match List.findMap matchEsc specialReprs with
  | Some c => c
  | None =>
    let code = x.code in
    if 32 <= code && code <= 127 then
      x.toString
    else
      code.format {fmt=IntFmt {base=16, prefix="\\x"}}
  end

{##
  Char format method.

  @param ?prec Parent precedence.
  @param ?fmt Format arguments.
 ##}
pub method format {?prec : Int, ?fmt : CharFmt} (self : Char) =
  let CharFmt {escape, asInt}         = fmt.unwrapOr CharFmt
  let CharFmt {size, fill, alignLeft} = fmt.unwrapOr CharFmt in
  match asInt with
    | Some fmt => self.code.format {prec=prec.unwrapOr 0, fmt}
    | None =>
      let res = 
        if escape.unwrapOr True == False then
          self.unescaped
        else
         (let escape = charRepr self in
          "'" + escape + "'")
      in padding res size fill alignLeft
  end

## ## String

{## String format options ##}
pub data StringFmt =
  {##
    String format options.

    @param ?escape Enables string escaping. On by default.
    @param ?size Total size.
    @param ?fill Padding fill character.
    @param ?alignLeft Padding direction.
   ##}
  StringFmt of { ?escape : Bool 
               , ?size : Int 
               , ?fill : Char
               , ?alignLeft : Bool }

{##
  String format method.

  @param ?prec Parent precedence.
  @param ?fmt Format options.
 ##}
pub method format {?prec : Int, ?fmt : StringFmt} (self : String) =
  let StringFmt {escape, size, fill, alignLeft} = fmt.unwrapOr StringFmt in
  if escape.unwrapOr True == False then
    padding self size fill alignLeft
  else
   (let xs = self.toList.map charRepr
    let res = "\"" + strListCat xs + "\"" in
    padding res size fill alignLeft)

## ## Bool

{## Bool format options. ##}
pub data BoolFmt = 
  {##
    Bool format options

    @param ?true Overrides True constructor.
    @param ?false Overrides False constructor.
    @param ?size Total size.
    @param ?fill Padding fill character.
    @param ?alignLeft Padding direction.
   ##}
  BoolFmt of { ?true : String
             , ?false : String
             , ?size : Int
             , ?fill : Char
             , ?alignLeft : Bool }

{##
  Bool format method.

  @param ?prec Parend precedence.
  @param ?fmt Bool format options.
 ##}
pub method format {?prec : Int, ?fmt : BoolFmt} (self : Bool) =
  let BoolFmt {true, false}           = fmt.unwrapOr BoolFmt 
  let BoolFmt {size, fill, alignLeft} = fmt.unwrapOr BoolFmt
  let ctor = 
    if self then 
      true.unwrapOr "True"
    else
      false.unwrapOr "False" in
  padding ctor size fill alignLeft

## ## List

pub data ListFmt A =
  {##
    Bool format options

    @param ?opn Overrides opening bracket.
    @param ?sep Overrides separator.
    @param ?cls Overrides closing bracket.
    @param ?inner Inner values' format.
    @param ?false Overrides False constructor.
    @param ?size Total size.
    @param ?fill Padding fill character.
    @param ?alignLeft Padding direction.
   ##}
  ListFmt of { ?opn : String
             , ?sep : String
             , ?cls : String
             , ?inner : A
             , ?size : Int 
             , ?fill : Char 
             , ?alignLeft : Bool }

{##
  List format method.

  @param ?prec Parend precedence.
  @param ?fmt Bool format options.
 ##}
pub method format 
  { method format : {?prec : Int, ?fmt : XFmt} -> X ->> String
  , ?prec : Int
  , ?fmt : ListFmt XFmt }
  (self : List X) =
    let ListFmt {opn, sep, cls, inner}  = fmt.unwrapOr ListFmt
    let ListFmt {size, fill, alignLeft} = fmt.unwrapOr ListFmt
    let opn = opn.unwrapOr "["
    let sep = sep.unwrapOr ", "
    let cls = cls.unwrapOr "]"
    # handles application of optional format param
    let appInner (x : X) =
      match inner with
      | Some fmt => x.format {fmt}
      | None     => x.format
      end
    let rec iter (xs : List X) =
      match xs with
      | [] => cls
      | [x] => appInner x + cls
      | x :: xs => appInner x + sep + iter xs
      end in
    let xs = opn + iter self in
    padding xs size fill alignLeft

## ## Option

{## Option format options. ##}
pub data OptionFmt A = 
  {##
    Option format options.

    @param ?some Overrides Some constructor.
    @param ?none Overrides None constructor.
    @param ?inner Inner value's format.
    @param ?size Total size.
    @param ?fill Padding fill character.
    @param ?alignLeft Padding direction.
    @param ?parenths Additional parenthesis.
   ##}
  OptionFmt of { ?some : String 
               , ?none : String
               , ?inner : A
               , ?size : Int
               , ?fill : Char
               , ?alignLeft : Bool
               , ?parenths : Bool }

{##
  Option format method.

  @param ?prec Parend precedence.
  @param ?fmt Bool format options.
 ##}
pub method format
  { method format : {?prec : Int, ?fmt : XFmt} -> X ->> String
  , ?prec : Int
  , ?fmt : OptionFmt XFmt }
  (self : Option X) =
    let OptionFmt {some, none, inner, parenths} = fmt.unwrapOr OptionFmt
    let OptionFmt {size, fill, alignLeft}       = fmt.unwrapOr OptionFmt
    let appInner (x : X) =
      match inner with
      | Some fmt => x.format {prec=200, fmt}
      | None     => x.format {prec=200}
      end
    let str =
      match self with
      | None => none.unwrapOr "None"
      | Some x => 
        let str = some.unwrapOr "Some " + appInner x in
        addParenths str 200 prec parenths
      end in
    padding str size fill alignLeft

## ## Pair

{## Pair format options. ##}
pub data PairFmt A B =
  {##
    Pair format options.

    @param ?opn Overrides opening parenth.
    @param ?sep Overrides separator.
    @param ?cls Overrides closing bracket.
    @param ?size Total size.
    @param ?fst Format for first value.
    @param ?snd Format for second value.
    @param ?fill Padding fill character.
    @param ?alignLeft Padding direction.
   ##}
  PairFmt of { ?opn : String 
             , ?sep : String
             , ?cls : String
             , ?fst : A
             , ?snd : B
             , ?size : Int
             , ?fill : Char
             , ?alignLeft : Bool }

{##
  Pair format method.

  @param ?prec Parend precedence.
  @param ?fmt Bool format options.
 ##}
pub method format 
  { method format : {?prec : Int, ?fmt : XFmt} -> X ->> String
  , method format : {?prec : Int, ?fmt : YFmt} -> Y ->> String
  , ?fmt : PairFmt XFmt YFmt
  , ?prec : Int }
  ((v1, v2) : Pair X Y) =
    let PairFmt {opn, sep, cls}         = fmt.unwrapOr PairFmt
    let PairFmt {fst, snd}              = fmt.unwrapOr PairFmt
    let PairFmt {size, fill, alignLeft} = fmt.unwrapOr PairFmt
    
    let fst = match fst with 
              | Some fmt => v1.format {fmt} 
              | None     => v1.format 
              end
    let snd = match snd with
              | Some fmt => v2.format {fmt}
              | None     => v2.format
              end
    
    let opn = opn.unwrapOr "("
    let sep = sep.unwrapOr ", "
    let cls = cls.unwrapOr ")"
    let res = opn + fst + sep + snd + cls in
    padding res size fill alignLeft

{# Either #}

{## Either format options. ##}
pub data EitherFmt A B =
  {##
    Either format options.

    @param ?left Overrides Left constructor.
    @param ?right Overrides Right constructor.
    @param ?innerL Format for left value.
    @param ?innerR Format for right value.
    @param ?size Total size.
    @param ?fill Padding fill character.
    @param ?alignLeft Padding direction.
    @param ?parenths Additional parenthesis.
   ##}
  EitherFmt of { ?left : String 
               , ?right : String
               , ?innerL : A
               , ?innerR : B
               , ?size : Int
               , ?fill : Char
               , ?alignLeft : Bool
               , ?parenths : Bool }

{##
  Either format method.

  @param ?prec Parend precedence.
  @param ?fmt Bool format options.
 ##}
pub method format 
  { method format : {?prec : Int, ?fmt : XFmt} -> X ->> String
  , method format : {?prec : Int, ?fmt : YFmt} -> Y ->> String
  , ?fmt : EitherFmt XFmt YFmt
  , ?prec : Int }
  (self : Either X Y) =
    let EitherFmt {size, fill, alignLeft, parenths} = fmt.unwrapOr EitherFmt
    let res = 
      match self with
      | Left x =>
        let EitherFmt {left, innerL} = fmt.unwrapOr EitherFmt
        let left = left.unwrapOr "Left " in
        match innerL with
        | Some fmt => left + x.format {prec=200, fmt}
        | None     => left + x.format {prec=200}
        end
      | Right y =>
        let EitherFmt {right, innerR} = fmt.unwrapOr EitherFmt
        let right = right.unwrapOr "Right " in
        match innerR with
        | Some fmt => right + y.format {prec=200, fmt}
        | None     => right + y.format {prec=200}
        end
      end
    let res = addParenths res 200 prec parenths in
    padding res size fill alignLeft
