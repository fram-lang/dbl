import /Test

data RefP = RefP of {Ref : type -> type}

let RefP {Ref} = (extern dbl_abstrType : Unit -> RefP) ()

data LazyState A =
  | Thunk of (Unit ->[] A)
  | Lock
  | Done of A

abstr data Lazy X = Lazy of Ref (LazyState X)

let ref {type X}    = (extern dbl_ref    : X -> Ref X)
method get {type X} = (extern dbl_refGet : Ref X -> X)
method set {type X} = (extern dbl_refSet : Ref X -> X -> Unit)

pub let lazy f = Lazy (ref (Thunk f))
pub let pureLazy {type X} (f : Unit ->[] X) = (lazy f : Lazy X)

pub method force (Lazy ref) =
  match ref.get with
  | Done x => x
  | Lock => runtimeError "Forcing lazy value during its evaluation"
  | Thunk f =>
    ref.set Lock;
    let val = f () in
    ref.set (Done val);
    val
  end

pub method format
  { X : type
  , method format : X ->> String }
  (self : Lazy X) =
    "(lazy (fn () => " + self.force.format + "))"

pub method map {X : type} (self : Lazy X) f =
  lazy (fn _ => f self.force)

pub let runTests () =
  open Test in
  testSuite "/Lazy" (fn _ =>
    testCase "`lazy.force` indentity" (fn _ =>
      assertEqF 10 (lazy (fn _ => 10)).force);
    ())
