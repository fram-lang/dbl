{# This file is part of DBL, released under MIT license.
 # See LICENSE for details.
 #}

## # List operations

## Checks if a list is empty.
pub let isEmpty xs =
  match xs with
  | [] => True
  | _  => False
  end

## Returns the length of a list (number of elements).
pub let length xs =
  let rec lengthAux xs (res : Int) =
    match xs with
    | []      => res
    | x :: xs => lengthAux xs (res + 1)
    end
  in lengthAux xs 0

## Returns the first element of a list or `None` if it's empty.
pub let hd xs =
  match xs with
  | []      => None
  | x :: xs => Some x
  end

{##
  Returns the first element of a list or calls `~onError` if it's empty.

  @param ~onError Fallback function for an empty list.
 ##}
pub let hdErr { ~onError } xs =
  match xs with
  | []      => ~onError ()
  | x :: xs => x
  end

## Returns the list without its first element or `None` if it's empty.
pub let tl xs =
  match xs with
  | []      => None
  | x :: xs => Some xs
  end

{##
  Returns the list without its first element or calls `~onError` if it's empty.

  @param ~onError Fallback function for an empty list.
 ##}
pub let tlErr { ~onError } xs =
  match xs with
  | []      => ~onError ()
  | x :: xs => xs
  end

{##
  Returns the list without the last element or returns `None` if it already
  was empty.
 ##}
pub let dropLast xs =
  let rec dropLastAux xs =
    match xs with
    | []  => impossible ()
    | [x] => []
    | x :: xs => x :: dropLastAux xs
    end in
  if isEmpty xs then
    None
  else
    Some (dropLastAux xs)

{##
  Returns the list without the last element or calls `~onError` if it already
  was empty.

  @param ~onError Fallback function in case of an empty list.
 ##}
pub let dropLastErr { ~onError } xs =
  let rec dropLastAux xs =
    match xs with
    | []  => impossible ()
    | [x] => []
    | x :: xs => x :: dropLastAux xs
    end in
  if isEmpty xs then
    ~onError ()
  else
    dropLastAux xs

{##
Returns the n-th element of a list or `None` if n is negative or the list
  is too short. The first element is at position 0.
 ##}
pub let nth xs (n : Int) =
  let rec nthAux xs (n : Int) =
    match xs with
    | []      => None
    | x :: xs => if n == 0 then Some x else nthAux xs (n - 1)
    end
  in if n < 0 then None else nthAux xs n

{##
  Returns the n-th element of a list or calls `~onError` if n is negative
  or the list is too short. The first element is at position 0.

  @param ~onError Fallback function for an empty list or negative index.
 ##}
pub let nthErr { ~onError } xs (n : Int) =
  let rec nthErrAux xs (n : Int) =
    match xs with
    | []      => ~onError ()
    | x :: xs => if n == 0 then x else nthErrAux xs (n - 1)
    end
  in if n < 0 then ~onError () else nthErrAux xs n

{##
  Returns the last element of a list or None if the list is empty.
 ##}
pub let last xs =
  let rec lastAux xs =
    match xs with
    | []      => None
    | [x]     => Some x
    | _ :: xs => lastAux xs
    end in
  lastAux xs

{##
  Returns the last element of a list or calls `~onError` if list is empty.

  @param ~onError Fallback for an empty list.
 ##}
pub let lastErr { ~onError } xs =
  let rec lastErrAux xs =
    match xs with
    | []      => ~onError ()
    | [x]     => x
    | _ :: xs => lastErrAux xs
    end in
  lastErrAux xs

{##
  Returns pair of combined results of `last` and `dropLast` functions,
  but performs this computation in more optimized manner. Returns
  `None` for an empty list.
 ##}
pub let dropTakeLast xs =
  let rec dropTakeLastAux xs =
    match xs with
    | []      => impossible ()
    | [x]     => ([], x)
    | x :: xs =>
      let (init, last) = dropTakeLastAux xs in
      (x :: init, last)
    end in
  if isEmpty xs then
    None
  else
    Some (dropTakeLastAux xs)

{##
  Returns pair of combined results of `last` and `dropLast` functions,
  but performs this computation in more optimized manner. Calls `~onError` for
  an empty list.

  @param ~onError Fallback for an empty list.
 ##}
pub let dropTakeLastErr { ~onError } xs =
  let rec dropTakeLastErrAux xs =
    match xs with
    | []      => impossible ()
    | [x]     => ([], x)
    | x :: xs =>
      let (init, last) = dropTakeLastErrAux xs in
      (x :: init, last)
    end in
  if isEmpty xs then
    ~onError ()
  else
    dropTakeLastErrAux xs

## Appends `ys` to `xs`.
pub let rec append xs ys =
  match xs with
  | []      => ys
  | x :: xs => x :: append xs ys
  end

## Reverses the first argument and appends it to the second argument.
pub let rec revAppend xs acc =
  match xs with
  | []      => acc
  | x :: xs => revAppend xs (x :: acc)
  end

## Returns the given list reversed.
pub let rev xs = revAppend xs []

{##
  Concatenates a list of lists. The elements of the given list are appended
  to each other consecutively.
 ##}
pub let rec concat xss =
  match xss with
  | []        => []
  | xs :: xss => append xs (concat xss)
  end

{##
  `map f xs` applies `f` to elements of `xs` and returns a list
  constructed from the results of these applications.
 ##}
pub let rec map f xs =
  match xs with
  | []      => []
  | x :: xs => f x :: map f xs
  end

{##
  Same as `List.map` but its argument `f` takes an additional argument which
  corresponds to index position of its first argument in `xs`.

  @param ?i Initial value of the iterator index. Defaults to 0.
 ##}
pub let rec mapi { ?i : Int } f xs =
  match i with
  | None   => mapi {i = 0} f xs
  | Some i =>
    match xs with
    | []      => []
    | x :: xs => f i x :: mapi {i = i + 1} f xs
    end
  end

{##
 `map2 f xs ys` returns a list constructed by applying `f` to consecutive
  pairs of elements from `xs` and `ys`.
  Calls `~onError` if the lists have different lengths.

  @param ~onError Fallback function for lists of different lengths.
 ##}
pub let map2 { ~onError } f xs ys =
  let rec map2Aux xs ys =
    match xs, ys with
    | [],      []      => []
    | x :: xs, y :: ys => f x y :: map2Aux xs ys
    | _,       _       => ~onError ()
    end
  in map2Aux xs ys

## `revMapAppend f xs ys` maps `f` onto reversed `xs` and appends it to `ys`.
pub let rec revMapAppend f xs ys =
  match xs with
  | []      => ys
  | x :: xs => revMapAppend f xs (f x :: ys)
  end

## `revMap f xs` returns `f` mapped onto reversed `xs`.
pub let revMap f xs = revMapAppend f xs []

{##
  `revMap2 f xs ys` returns a list constructed by applying `f` to consecutive
  pairs of elements from reversed `xs` and `ys`.
  Calls `~onError` if the lists have different lengths.

  @param ~onError Fallback function for lists of different lengths.
 ##}
pub let revMap2 { ~onError } f xs ys =
  let rec revMap2Aux acc xs ys =
    match xs, ys with
    | [],      []      => acc
    | x :: xs, y :: ys => revMap2Aux (f x y :: acc) xs ys
    | _,       _       => ~onError ()
    end
  in revMap2Aux [] xs ys

## `filter p xs` returns list of elements of `xs` which satisfy predicate `p`.
pub let rec filter p xs =
  match xs with
  | []      => []
  | x :: xs => if p x then x :: filter p xs else filter p xs
  end

{##
  Same as `List.filter` but its argument `p` takes an additional argument which
  corresponds to index position of its first argument in `xs`.

  @param ?i Initial value of the iterator index. Defaults to 0.
 ##}
pub let rec filteri { ?i : Int } p xs =
  match i with
  | None   => filteri {i = 0} p xs
  | Some i =>
    match xs with
    | []      => []
    | x :: xs =>
      if p i x then x :: filteri {i = i + 1} p xs
      else filteri {i = i + 1} p xs
    end
  end

{##
  Same as `List.filter` but `f` returns an `Option`. Returns a list of
  arguments on which `f` returned `Some`.
 ##}
pub let rec filterMap f xs =
  match xs with
  | []      => []
  | x :: xs =>
    match f x with
    | None   => filterMap f xs
    | Some x => x :: filterMap f xs
    end
  end

{##
  Same as `List.filterMap` and `List.filteri`.

  @param ?i Initial value of the iterator index. Defaults to 0.
 ##}
pub let rec filterMapi { ?i : Int } f xs =
  match i with
  | None   => filterMapi {i = 0} f xs
  | Some i =>
    match xs with
    | []      => []
    | x :: xs =>
      match f x i with
      | None   => filterMapi {i = i + 1} f xs
      | Some x => x :: filterMapi {i = i + 1} f xs
      end
    end
  end

## `concatMap f xs` maps `f` onto `xs` and then concatenates the result.
pub let concatMap f xs = concat (map f xs)

{##
  Returns prefix of length n of a list or the list itself if it's shorter than n.
 ##}
pub let rec take (n : Int) xs =
  match xs with
  | []      => []
  | x :: xs => if n == 0 then [] else x :: take (n - 1) xs
  end

## Returns suffix of a list after n elements or `[]` if it's shorter than n.
pub let rec drop (n : Int) xs =
  if n <= 0 then xs else
    match xs with
    | []      => []
    | x :: xs => drop (n - 1) xs
    end

## Returns the longest prefix of a list of which elements satisfy `p`.
pub let rec takeWhile p xs =
  match xs with
  | []      => []
  | x :: xs => if p x then x :: takeWhile p xs else []
  end

## Returns the longest suffix of a list of which first element satisfies `p`.
pub let rec dropWhile p xs =
  match xs with
  | []       => []
  | x :: xs' => if p x then dropWhile p xs' else xs
  end

## `iter f xs` applies `f` to all elements of `xs` in order.
pub let rec iter f xs =
  match xs with
  | []      => ()
  | x :: xs => f x; iter f xs
  end

{##
  Same as `List.iter` but it takes an additional optional parameter `i`
  which is incremented with every consecutive application of `f`, which itself
  takes an additional argument.

  @param ?i Initial value of the iterator index. Defaults to 0.
 ##}
pub let rec iteri { ?i : Int } f xs =
  match i with
  | None   => iteri {i = 0} f xs
  | Some i =>
    match xs with
    | []      => ()
    | x :: xs => f i x; iteri {i = i + 1} f xs
    end
  end

{##
  Applies a function to consecutive pairs of elements of the given lists.
  Calls `~onError` if the lists have different lengths.

  @param ~onError Fallback function for lists of different lengths.
 ##}
pub let iter2 { ~onError } f xs ys =
  let rec iter2Aux xs ys =
    match xs, ys with
    | [],      []      => ()
    | x :: xs, y :: ys => f x y; iter2Aux xs ys
    | _                => ~onError ()
    end
  in iter2Aux xs ys

{##
  `init n f` returns a list of n elements constructed by applying `f` to
  the index of current element. Optional parameter `i` sets the value of the
  starting index which by default is 0.

  @param ?i Initial value of the iterator index. Defaults to 0.
 ##}
pub let rec init { ?i : Int } (len : Int) f =
  match i with
  | None    => init {i = 0} len f
  | Some i =>
    let rec initAux (i : Int) f =
      if i >= len then []
      else f i :: initAux (i + 1) f
    in initAux i f
  end

## `foldLeft f init [x1, x2, ... ,xn]` is `f (... (f (f init x1) x2) ...) xn`.
pub let rec foldLeft f acc xs =
  match xs with
  | []      => acc
  | x :: xs => foldLeft f (f acc x) xs
  end

{##
 `foldLeft f [x1, x2, ... ,xn]` is `f (... (f (f x1 x2) x3) ...) xn`.
 Returns `None` in case of an empty list.
 ##}
pub let rec foldLeft1 f xs =
  match xs with
  | [] => None
  | x :: xs => Some (foldLeft f x xs)
  end

{##
 `foldLeft f [x1, x2, ... ,xn]` is `f (... (f (f x1 x2) x3) ...) xn`.
 Returns `~onError` in case of an empty list.

 @param ~onError Fallback for an empty list.
 ##}
pub let rec foldLeft1Err { ~onError } f xs =
  match xs with
  | [] => ~onError ()
  | x :: xs => foldLeft f x xs
  end

## `foldRight f [x1, x2, ..., xn] init` is `f x1 (f x2 (... (f xn init)))`.
pub let rec foldRight f xs acc =
  match xs with
  | []      => acc
  | x :: xs => f x (foldRight f xs acc)
  end

{##
  `foldRight f [x1, x2, ..., xn]` is `f x1 (... (f x(n-1) xn)))`.
  Returns `None` for an empty list.
 ##}
pub let foldRight1 f xs =
  let rec foldRight1Aux xs =
    match xs with
    | x :: y :: [] => f x y
    | x :: xs      => f x (foldRight1Aux xs)
    | _            => impossible ()
    end in
  if isEmpty xs then
    None
  else
    Some (foldRight1Aux xs)

{##
  `foldRight f [x1, x2, ..., xn]` is `f x1 (... (f x(n-1) xn)))`.
  Calls `~onError` for an empty list.

  @param ~onError Fallback for an empty list.
 ##}
pub let foldRight1Err { ~onError } f xs =
  let rec foldRight1ErrAux xs =
    match xs with
    | x :: y :: [] => f x y
    | x :: xs      => f x (foldRight1ErrAux xs)
    | _            => impossible ()
    end in
  if isEmpty xs then
    ~onError ()
  else
    foldRight1ErrAux xs

{##
  `foldLeft2 f init xs ys` works the same as `List.foldLeft` but `f` is
  applied to consecutive pairs of elements from `xs` and `ys`.
  Calls `~onError` if the lists have different lengths.

  @param ~onError Fallback function for lists of different lengths.
 ##}
pub let foldLeft2 { ~onError } f acc xs ys =
  let rec foldLeft2Aux acc xs ys =
    match xs, ys with
    | [],      []      => acc
    | x :: xs, y :: ys => foldLeft2Aux (f acc x y) xs ys
    | _,       _       => ~onError ()
    end
  in foldLeft2Aux acc xs ys

{##
  Same as `List.foldRight` and `List.foldLeft2`.

  @param ~onError Fallback function for lists of different lengths.
 ##}
pub let foldRight2 { ~onError } f xs ys acc =
  let rec foldRight2Aux xs ys acc =
    match xs, ys with
    | [],      []      => acc
    | x :: xs, y :: ys => f x y (foldRight2Aux xs ys acc)
    | _,       _       => ~onError ()
    end
  in foldRight2Aux xs ys acc

## Checks if all elements of a list satisfy a predicate.
pub let rec forAll p xs =
  match xs with
  | []      => True
  | x :: xs => p x && forAll p xs
  end

{##
  Checks if all consecutive pairs of elements of the given lists satisfy `p`.
  Calls `~onError` if the lists have different lengths.

  @param ~onError Fallback function for lists of different lengths.
 ##}
pub let forAll2 { ~onError } p xs ys =
  let rec forAll2Aux xs ys =
    match xs, ys with
    | [],      []      => True
    | x :: xs, y :: ys => p x y && forAll2Aux xs ys
    | _,       _       => ~onError ()
    end
  in forAll2Aux xs ys

## Checks if a list contains an element which satisfies a predicate.
pub let rec exists p xs =
  match xs with
  | []      => False
  | x :: xs => p x || exists p xs
  end

{##
  Checks if there exists a pair of elements at the same position
  in the given lists that satisfies `p`.
  Calls `~onError` if the lists have different lengths.

  @param ~onError Fallback function for lists of different lengths.
 ##}
pub let exists2 { ~onError } p xs ys =
  let rec exists2Aux xs ys =
    match xs, ys with
    | [],      []      => False
    | x :: xs, y :: ys => p x y || exists2Aux xs ys
    | _,       _       => ~onError ()
    end
  in exists2Aux xs ys

{##
  Returns the first element of a list that satisfies `p` or `None` if
  there is no such element.
 ##}
pub let rec find p xs =
  match xs with
  | []      => None
  | x :: xs => if p x then Some x else find p xs
  end

{##
  Returns the first element of a list that satisfies `p` or calls `~onError` if
  there is no such element.

  @param ~onError Fallback function in case the predicate is not satisfied.
 ##}
pub let findErr { ~onError } p xs =
  let rec findErrAux p xs =
    match xs with
    | []      => ~onError ()
    | x :: xs => if p x then x else findErrAux p xs
    end
  in findErrAux p xs

{##
  Returns the index of the first element of a list that satisfies `p` or `None`
  if there is no such element.
 ##}
pub let findIndex p xs =
  let rec findIndexAux (i : Int) xs =
    match xs with
    | []      => None
    | x :: xs => if p x then Some i else findIndexAux (i + 1) xs
    end
  in findIndexAux 0 xs

{##
  Returns the index of the first element of a list that satisfies `p` or calls
  `~onError` if there is no such element.

  @param ~onError Fallback function in case the predicate is not satisfied.
 ##}
pub let findIndexErr { ~onError } p xs =
  let rec findIndexErrAux (i : Int) xs =
    match xs with
    | []      => ~onError ()
    | x :: xs => if p x then i else findIndexErrAux (i + 1) xs
    end
  in findIndexErrAux 0 xs

{##
  Returns the first non-`None` result from iteratively applying `f` to each
  element of the given list or `None` if there is no such result.
 ##}
pub let rec findMap f xs =
  match xs with
  | []      => None
  | x :: xs =>
    match f x with
    | Some x => Some x
    | None   => findMap f xs
    end
  end

{##
  Returns the first non-`None` value from iteratively applying `f` to each
  element of the given list or calls `~onError` if there is no such result.

  @param ~onError Fallback function in case the all results are `None`.
 ##}
pub let findMapErr { ~onError } f xs =
  let rec findMapErrAux f xs =
    match xs with
    | []      => ~onError ()
    | x :: xs =>
      match f x with
      | None   => findMapErrAux f xs
      | Some x => x
      end
    end
  in findMapErrAux f xs

{##
  Same as `List.findMap` but its argument `f` takes an additional argument which
  corresponds to index position of its first argument in `xs`.

  @param ?i Initial value of the iterator index. Defaults to 0.
 ##}
pub let rec findMapi { ?i : Int } f xs =
  match i with
  | None   => findMapi {i = 0} f xs
  | Some i =>
    match xs with
    | []      => None
    | x :: xs =>
      match f i x with
      | Some x' => Some x'
      | None    => findMapi {i = i + 1} f xs
      end
    end
  end

{##
  Same as `List.findMapErr` but its argument `f` takes an additional argument which
  corresponds to index position of its first argument in `xs`.

  @param ~onError Fallback function in case all results are `None`.
  @param ?i Initial value of the iterator index. Defaults to 0.
 ##}
pub let rec findMapiErr { ~onError, ?i : Int } f xs =
  match i with
  | None   => findMapiErr {i = 0} f xs
  | Some i =>
    match xs with
    | []      => ~onError ()
    | x :: xs =>
      match f i x with
      | Some x => x
      | None   => findMapiErr {i = i + 1} f xs
      end
    end
  end

{##
  Returns a pair of which first element is the same as `List.foldLeft` and its
  second element is a new list. `f` returns a pair of values, first being the
  new accumulator and second being a value added to the list in the result.
 ##}
pub let foldLeftMap f acc xs =
  let rec foldLeftMapAux acc l_acc xs =
    match xs with
    | []      => acc, rev l_acc
    | x :: xs =>
      let (acc, x) = f acc x in
      foldLeftMapAux acc (x :: l_acc) xs
    end
  in foldLeftMapAux acc [] xs

{##
  Same as `List.foldLeftMap` but `f` returns an `Option` and the accumulator
  and constructed list are updated when the result of `f` is not `None`.
 ##}
pub let foldLeftFilterMap f acc xs =
  let rec foldLeftFilterMapAux acc l_acc xs =
    match xs with
    | []      => acc, rev l_acc
    | x :: xs =>
      match f acc x with
      | None          => foldLeftFilterMapAux acc l_acc xs
      | Some (acc, x) => foldLeftFilterMapAux acc (x :: l_acc) xs
      end
    end
  in foldLeftFilterMapAux acc [] xs

## Same as `List.foldLeftMap` but it concatenates the new list.
pub let foldLeftConcatMap f acc xs =
  let (acc, xs) = foldLeftMap f acc xs
  in (acc, concat xs)

## ## Operations on lists containing comparable elements

## Checks if a list contains an element equal to the given value.
pub let mem
  { E, method equal : E -> E ->[] Bool }
  (v : E) (xs : List E) =
  let rec memAux (xs : List E) =
    match xs with
    | []      => False
    | x :: xs => v == x || memAux xs
    end
  in memAux xs

{##
  Checks if two lists have the same lengths and their elements at corresponding
  positions are equal.
 ##}
pub let equal
  { E, method equal : E -> E ->[] Bool }
  (xs : List E) (ys : List E) =
  let rec equalAux (xs : List E) (ys : List E) =
    match xs, ys with
    | [],      []      => True
    | x :: xs, y :: ys => x == y && equalAux xs ys
    | _,       _       => False
    end
  in equalAux xs ys

{# method versions of these functions #}
parameter ~onError

pub method isEmpty = isEmpty
pub method length = length
pub method hd = hd
pub method hdErr = hdErr
pub method tl = tl
pub method tlErr = tlErr
pub method dropLast = dropLast
pub method dropLastErr = dropLastErr
pub method nth = nth
pub method nthErr = nthErr
pub method last = last
pub method lastErr = lastErr
pub method dropTakeLast = dropTakeLast
pub method dropTakeLastErr = dropTakeLastErr
pub method append = append
pub method add = append
pub method revAppend = revAppend
pub method rev = rev
pub method concat = concat
pub method map self f = map f self
pub method mapi { ?i : Int } self f = mapi { ?i = i } f self
pub method revMapAppend self f ys = revMapAppend f self ys
pub method revMap self f = revMap f self
pub method filter self p = filter p self
pub method filteri { ?i : Int } self p = filteri { ?i = i } p self
pub method filterMap self f = filterMap f self
pub method concatMap self f = concatMap f self
pub method drop self n = drop n self
pub method takeWhile self p = takeWhile p self
pub method dropWhile self p = dropWhile p self
pub method iter self f = iter f self
pub method iteri { ?i : Int } self f = iteri { ?i = i } f self
pub method foldLeft self f acc = foldLeft f acc self
pub method foldLeft1 self f = foldLeft1 self f
pub method foldLeft1Err self f = foldLeft1Err self f
pub method foldRight self f acc = foldRight f self acc
pub method foldRight1 self f = foldRight1 f self
pub method foldRight1Err self f = foldRight1Err f self
pub method forAll self p = forAll p self
pub method exists self p = exists p self
pub method find self p = find p self
pub method findErr self p = findErr p self
pub method findIndex self p = findIndex p self
pub method findIndexErr self p = findIndexErr p self
pub method findMap self f = findMap f self
pub method findMapErr self f = findMapErr f self
pub method findMapi { ?i : Int } self f = findMapi { ?i = i } f self
pub method findMapiErr { ?i : Int } self f = findMapiErr { ?i = i } f self
pub method foldLeftMap self f acc = foldLeftMap f acc self
pub method foldLeftFilterMap self f acc = foldLeftFilterMap f acc self
pub method foldLeftConcatMap self f acc = foldLeftConcatMap f acc self
pub method mem { E, method equal : E -> E ->[] Bool } self v =
  mem {E} v self
pub method equal { E, method equal : E -> E ->[] Bool } self xs =
  equal {E} self xs
pub method neq { E, method equal : E -> E ->[] Bool } self xs =
  not (equal {E} self xs)
