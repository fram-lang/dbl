{# This file is part of DBL, released under MIT license.
 # See LICENSE for details.
 #}

#==============================================================================
# Red Black Tree implementation
#==============================================================================

# Due to frequent request for understanding this file please
# see comments at the end of this file

import List

data Color =
  | Red
  | Black

data rec Tree Value =
  | Leaf
  | Node of {
      color: Color,
      size: Int,
      left: Tree Value,
      value: Value,
      right: Tree Value
    }

{# Red-black invariant: 
#        no red node has a red child
#        Black height invariant: 
#           for every t = Node(_, _, left, _, right),
#           black-height(left) = black-height(right)
#        Leaves are considered black, but do not contribute to black height.
#}

data ZipElem Value =
  | Left of Color, Value, Tree Value
  | Right of Color, Tree Value, Value

# Empty tree
let empty = Leaf

# Return cached size
let size tree =
  match tree with
  | Leaf => 0
  | Node {size} => size
  end

# Smart constructor that updates the size of node
let makeNode color left value right =
  Node {color, size = size left + size right + 1, left, value, right}

# Constructor for node
let construct color size left value right =
  Node {color,size,left,value,right}

# Walk upward applying recorded decisions (zipper) to rebuild tree
let rec zip tree zipper =
  match zipper with
  | [] => tree

  | Left color value right :: rest =>
    zip (makeNode color tree value right) rest

  | Right color left value :: rest =>
    zip (makeNode color left value tree) rest

 end

{# Precondition:
 #  (zip (Node (RED, size, left, value ,right) zipper) 
 #  satisfies the black-height invariant, 
 #  and also satisfies the red-black 
 #  invariant except possibly locally
 #}
let rec zipRed value left right zipper =
  match zipper with
  # Root case
  | [] => makeNode Black left value right
  
  # Father is black and we are left child then we recreate the node
  # and we are rebuilding tree 
  | Left Black value1 right1 :: rest =>
    zip (makeNode Black (makeNode Red left value right) value1 right1) rest

  
  # Father is black and we are right child then we recreate the node
  # and we are rebuilding tree 
  | Right Black left1 value1  :: rest =>
    zip (makeNode Black left1 value1 (makeNode Red left value right)) rest

  # Father is Red and left child, the uncle is Red and we are left child. 
  # The father and uncle are colored Black.
  # ZipRed is recursively called on the grandfather.
  | Left Red value1 right1 ::
      Left _ value2
      (Node {color = Red, size = size3, left = left3,
      value = value3, right = right3}) :: rest =>
    let left'  = makeNode Red left value right
    let right' = construct Black size3 left3 value3 right3 in
    zipRed value2 (makeNode Black left' value1 right1) right' rest

  # Father is Red and right child, the uncle is Red and we are left child. 
  # The father and uncle are colored Black.
  # ZipRed is recursively called on the grandfather.
  | Left Red value1 right1 ::
      Right _
      (Node {color = Red, size = size3, left = left3,
      value = value3, right = right3}) value2 :: rest =>
    let left'  = construct Black size3 left3 value3 right3
    let right' = makeNode Red left value right in
    zipRed value2 left' (makeNode Black right' value1 right1) rest

  # Father is Red and left child, the uncle is Red and we are right child. 
  # The father and uncle are colored Black.
  # ZipRed is recursively called on the grandfather.
  | Right Red left1 value1 ::
      Left _ value2
      (Node {color = Red, size = size3, left = left3,
      value = value3, right = right3}) :: rest =>
    let left'  = makeNode Red left value right
    let right' = construct Black size3 left3 value3 right3 in
    zipRed value2 (makeNode Black left1 value1 left') right' rest

  # Father is Red and right child, the uncle is Red and we are right child. 
  # The father and uncle are colored Black.
  # ZipRed is recursively called on the grandfather.
  | Right Red left1 value1 ::
      Right _ (Node {color = Red, size = size3, left = left3,
      value = value3, right = right3}) value2 :: rest =>
    let left'  = construct Black size3 left3 value3 right3
    let right' = makeNode Red left value right in
    zipRed value2 left' (makeNode Black left1 value1 right') rest

  # Father is Red and left child, the uncle is Black and we are left child. 
  # The father and uncle are colored Red.
  # The grandfather is then black and we are rebuilding the tree.
  | Left Red value1 right1 :: Left _ value2 node3 :: rest =>
    let left'  = makeNode Red left value right
    let right' = makeNode Red right1 value2 node3 in
    zip (makeNode Black left' value1 right') rest
  
  # Father is Red and right child, the uncle is Black and we are left child. 
  # The father and uncle are colored Red.
  # The grandfather is then black and we are rebuilding the tree.
  | Left Red value1 right1 :: Right _ node3 value2  :: rest =>
    let left'  = makeNode Red node3 value2 left
    let right' = makeNode Red right value1 right1 in
    zip (makeNode Black left' value right') rest

  # Father is Red and left child, the uncle is Black and we are right child. 
  # The father and uncle are colored Red.
  # The grandfather is then black and we are rebuilding the tree.
  | Right Red left1 value1 :: Left _ value2 node3 :: rest =>
    let left'  = makeNode Red left1 value1 left
    let right' = makeNode Red right value2 node3 in
    zip (makeNode Black left' value right') rest

  # Father is Red and right child, the uncle is Black and we are right child. 
  # The father and uncle are colored Red.
  # The grandfather is then black and we are rebuilding the tree.
  | Right Red left1 value1 :: Right _  node3 value2 :: rest =>
    let left'  = makeNode Red node3 value2 left1
    let right' = makeNode Red left value right in
    zip (makeNode Black left' value1 right') rest

  # The father is Red and a root and we are left child.
  # The functions correct invariant about root.
  | Left Red value1 right1 :: [] =>
    makeNode Black (makeNode Red left value right) value1 right1

  # The father is Red and a root and we are right child.
  # The functions correct invariant about root.
  | Right Red left1 value1 :: [] =>
    makeNode Black left1 value1 (makeNode Red left value right)

 end

{# Precondition:
#       1. tree is black
#       2. (zip tree zipper) satisfies the red-black invariant, and it
#          would satisfy the black-height invariant if the black-height of
#          tree were one higher
#}
let rec zipBlack tree zipper =
  match zipper with
  # Root case
  | [] => tree

  # Tree is left child, and right nephew is Red.
  #     father(C)                          brother(C)
  #     /    \                            /      \
  # tree      brother       ->        father(B)    rnephew(B)
  #           /     \                 /     \
  #       lnephew   rnephew(R)      tree      lnephew
  # After rotation, the whole tree is reconstructed
  | Left color1 value1
      (Node {left = left2, value = value2,
      right = (Node {color = Red, size = size3,
      left = left3, value = value3, right = right3})}) ::
      rest =>
    let left'  = makeNode Black tree value1 left2
    let right' = construct Black size3 left3 value3 right3 in
    zip (makeNode color1 left' value2 right') rest

  # Tree is right child, and left nephew is Red.
  #             Cfather                   Cbrother
  #           /        \                 /        \
  #     brother         tree    ->  Blnephew      Bfather
  #    /       \                                  /     \
  # Rlnephew   rnephew                       rnephew    tree
  # After rotation, the whole tree is reconstructed
  | Right color1 (Node { left = (Node {color = Red, size = size3, left = left3,
      value = value3, right = right3}), value = value2, right = right2})
      value1 :: rest =>
    let left'  = construct Black size3 left3 value3 right3
    let right' = makeNode Black right2 value1 tree in
    zip (makeNode color1 left' value2 right') rest
  
  # Tree is left child, and right nephew is Red.
  #     Cfather                           Crnephew
  #     /    \                            /      \
  # tree      brother       ->        Bfather    Bbrother
  #           /     \                 /    \      /     \
  #       Rlnephew  Brnephew      tree   left   right   Brnephew
  #       /      \
  #     left     right
  # After rotation, the whole tree is reconstructed
  | Left color1 value1 (Node {left = (Node {color = Red, left = left3,
      value = value3, right = right3}),
      value = value2, right = right2}) :: rest =>
    let left'  = makeNode Black tree value1 left3
    let right' = makeNode Black right3 value2 right2 in
    zip (makeNode color1 left' value3 right') rest

  # Tree is right child, and left nephew is Red.
  #             Cfather                     Crnephew
  #           /        \                  /         \
  #     brother         tree    ->   Bbrother       Bfather
  #    /       \                     /     \         /    \
  # Blnephew   Rrnephew          Blnephew  left    right   tree
  #           /     \
  #         left    right
  # After rotation, the whole tree is reconstructed
  | Right color1 (Node {left = left2, value = value2, right =
      (Node {color = Red, left = left3, value = value3, right = right3})})
      value1 :: rest =>
    let left'  = makeNode Black left2 value2 left3
    let right' = makeNode Black right3 value1 tree in
    zip (makeNode color1 left' value3 right') rest

  # The father is red and no nephew is red.
  # Then father becomes black and brother becomes red
  # removing therfore the inequality of blackness. 
  # After that, the whole tree is reconstructed.
  | Left Red value1 (Node {size = size2, left = left2,
      value = value2, right = right2}) :: rest =>
    let right' = construct Red size2 left2 value2 right2 in
    zip (makeNode Black tree value1 right') rest

  # The father is red and no nephew is red.
  # Then father becomes black and brother becomes red
  # removing therfore the inequality of blackness. 
  # After that, the whole tree is reconstructed.
  | Right Red (Node {size = size2, left = left2,
      value = value2, right = right2}) value1 :: rest =>
    let left' = construct Red size2 left2 value2 right2 in
    zip (makeNode Black left' value1 tree) rest

  # The father is black and no nephew is red.
  # Brother becomes red but the inequality of blackness is sustained. 
  # ZipBlack recursively called on the father.
  | Left Black value1 (Node {color = Black, size = size2, left = left2,
      value = value2, right = right2}) :: rest =>
    let right' = construct Red size2 left2 value2 right2 in
    zipBlack (makeNode Black tree value1 right') rest
  
  # The father is black and no nephew is red.
  # Brother becomes red but the inequality of blackness is sustained. 
  # ZipBlack recursively called on the father.
  | Right Black (Node {color = Black, size = size2, left = left2,
      value = value2, right = right2}) value1 :: rest =>
    let left' = construct Red size2 left2 value2 right2 in
    zipBlack (makeNode Black left' value1 tree) rest

  # The father is black and no nephew is red.
  # Brother becomes red but the inequality of blackness is sustained. 
  # ZipBlack recursively called on the father.
  | Left Black value1 (Node {color = Red, left = left2,
      value = value2, right = right2}) :: rest =>
    zipBlack tree (Left Red value1 left2 :: Left Black value2 right2 :: rest)

  # The father is black and no nephew is red.
  # Brother becomes red but the inequality of blackness is sustained. 
  # ZipBlack recursively called on the father.
  | Right Black (Node {color = Red, left = left2, value = value2,
      right = right2}) value1 :: rest =>
    let rest' = Right Red right2 value1 :: Right Black left2 value2 :: rest in
    zipBlack tree rest'

  # Impossible
  | Left _ _ Leaf :: _ => impossible ()

  | Right _ Leaf _  :: _ => impossible ()

 end

# search splits tree according to compare function and builds zipper
let rec search func tree zipper =
  match tree with
  | Leaf => (Leaf, zipper)
  | Node {color, left, value, right} =>
    match func value with
    | Lt =>
      search func left (Left color value right :: zipper)
    | Gt =>
      search func right (Right color left value  :: zipper)
    | Eq => (tree, zipper)
    end
  end

# serachMin finds smallest element in a tree and builds zipper
let rec searchMin tree zipper =
  match tree with
  | Leaf => zipper
  | Node {color, left, value, right} =>
    searchMin left (Left color value right :: zipper)
  end

# serachMax finds largest element in a tree and builds zipper
let rec searchMax tree zipper =
  match tree with
  | Leaf => zipper
  | Node {color, left, value, right} =>
    searchMax right (Right color left value:: zipper)
  end

{# Removes a node if one of the child is a Leaf and rebuilds tree
# Precondition:
#   (zip (Node (color, _, _, Leaf, child)) zipper) is a valid tree,
#   or (zip (Node (color, _, _, child, Leaf)) zipper) is a valid tree.
#}
let deleteNearLeaf color child zipper =
  match color with
  {# child cannot be RED, by red-black invariant,
     so it must be Leaf, by black-height invariant.
  #}
  | Red => zip Leaf zipper
  | Black =>
    match child with
    | Node {value} =>
      # Must be RED with Leaf children, by black-height invariant.
      zip (makeNode Black Leaf value Leaf) zipper
    | Leaf => zipBlack Leaf zipper
    end
  end

{# Deletes node and adds children correctly to zipper and zip back the tree
  Precondition:
    zip (Node (color, _, _, left, right)) zipper is a valid tree.
#}
let delete color left right zipper =
  match right with
  | Leaf =>
    match left with
    | Leaf =>
      match color with
      | Red => zip Leaf zipper
      | Black => zipBlack Leaf zipper
      end
    | _ =>
      match searchMax left [] with
      | Right colorLeftMin leftLeftMin valueLeftMin :: zipperr =>
        deleteNearLeaf colorLeftMin leftLeftMin
            (List.append zipperr (Left color valueLeftMin right :: zipper))
      | _ => Leaf #Fail "postcondition"
      end
    end
  | _ =>
    match searchMin right [] with
    | Left colorRightMin valueRightMin rightRightMin :: zipperr =>
      deleteNearLeaf colorRightMin rightRightMin
          (List.append zipperr (Right color left valueRightMin :: zipper))
    | _ => Leaf #Fail "postcondition"
    end
  end

# makes a root black
let blacken tree =
  match tree with
  | Node {color = Red, size, left, value, right} =>
    construct Black size left value right
  | _ => tree
  end

# returns black height
let rec blackHeight tree acc =
  match tree with
  | Leaf => acc
  | Node {color=Red,left} => blackHeight left acc
  | Node {color=Black,left} => blackHeight left (1 + acc)
  end

{#  precondition: blackHeight(tree) >= target >= 0
    find a black subtree along the left/right spine whose black-height is
    blackHeight(tree) - target.
#}
let rec searchHeight leftward target tree zipper =
  match tree with
  | Leaf => (Leaf, zipper)
  | Node {color=Red,left,value,right} =>
    if leftward then
      searchHeight leftward target left (Left Red value right :: zipper)
    else
      searchHeight leftward target right (Right Red  left value :: zipper)
  | Node {color=Black,left,value,right} =>
    if 0 == target then
      (tree,zipper)
    else if leftward then
      searchHeight leftward (target - 1) left
          (Left Black value right :: zipper)
    else
      searchHeight leftward (target - 1) right
          (Right Black left value :: zipper)
  end

# adds element to the tree
let joinVal left value right =
  # without loss of generality, assume left and right have black roots
  let left = blacken left in
  let right = blacken right in
  let lbh = blackHeight left 0 in
  let rbh = blackHeight right 0 in
  if lbh == rbh then
    makeNode Black left value right
  else if lbh > rbh then
    (let (_left, zipper) = searchHeight False (lbh-rbh) left [] in
    # left' and right are both black and both have black height rbh 
    zipRed value _left right zipper)
  else
    (let (_right, zipper) = searchHeight True (rbh-lbh) right [] in
    # left and right' are both black and both have black height lbh 
    zipRed value left _right zipper)

# joins two trees
let join left right =
  match left with
  | Leaf => right
  | _ =>
    match right with
    | Leaf => left
    | _ =>
      match searchMax left [] with
      | Right color  leftSmall value :: zipper =>
        joinVal (deleteNearLeaf color leftSmall zipper) value right
      |_  => left
      end
    end
  end

# Splits tree according to the function 
let rec split compareWithPivot tree =
  match tree with
  | Leaf => (None,Leaf,Leaf)
  | Node {left,value,right} =>
    match compareWithPivot value with
    | Eq => (Some value, left, right)
    | Lt =>
      let (_v, _l, _r) = split compareWithPivot left in
      (_v, _l, joinVal _r value right)
    | Gt => let (_v, _l, _r) = split compareWithPivot right in
      (_v, joinVal left value  _l, _r)
    end
  end

#==============================================================================
# Ordered Map signature
#==============================================================================

parameter ~onError

pub data Map Key = Map of {
  T

 {## @brief Creates empty map
   ##}
  , empty : {Val} -> T Val

 {## @brief Method to testing whether given map is empty or not
   # @return True if it's empty false otherwise
   ##}
  , method isEmpty : {Val} -> T Val ->[] Bool


 {## @brief Method to get size of map
   # @return Integer that is a size of map
   ##}
  , method size : {Val} -> T Val ->[] Int

 {## @brief Method for inserting element to the map
   # @param Key which will be inserted to the map
   # @param Value which will be inserted to the map
   # @return Map with inserted value
   ##}
  , method insert : {Val} -> T Val ->
      Key -> Val ->[] T Val

 {## @brief Method for inserting element to the map
   # @param Key which will be inserted to the map
   # @param Value which will be inserted to the map
   # @return Map with inserted value
   # and boolean value if the value was changed
   # if the key already existed in map
   ##}
  , method insertChange : {Val} -> T Val ->
      Key -> Val ->[] (Pair (T Val) Bool)

 {## @brief Method for removing key from the map
   # @param Key which will be removed to the map
   # @return Map with removed key
   ##}
  , method remove : {Val} -> T Val -> Key ->[] T Val

 {## @brief Method for removing key from the map
   # @param Key which will be removed to the map
   # @return Map with removed key
   #  and boolean value if the map was changed
   ##}
  , method removeChange : {Val} -> T Val ->
      Key ->[] (Pair (T Val) Bool)

 {## @brief Method for checking if a given key is present in a map
   ##}
  , method member : {Val} -> T Val -> Key ->[] Bool

 {## @brief Method for getting value mapping from a key
   #   returns None if key is not found
   ##}
  , method find : {Val} -> T Val -> Key ->[] Option Val

 {## @brief Method for getting value mapping from a key,
   #   calls `~onError` if key is not found
   ##}
  , method findErr :
    {Val, Err, ~onError : Unit ->[Err] Val} -> T Val -> Key ->[Err] Val

 {## @brief Method to update mapping on a key using a function
   # @param key
   # @param f is called with Option Val based on if the key has mapping
   #     in the input tree and should return Option Val to update the tree
   # @return updated tree
   ##}
  , method update : {Val,E} -> T Val -> Key ->
      (Option Val ->[E] Option Val) ->[E] T Val

 {## @brief Method to fold left through structure of map
   # @param Function that receives key, value and accumulator
   # @param Accumulator
   # @return Result of applying function on keys
   # and values of map and accumulator
   ##}
  , method foldl : {Val, type A,E} -> T Val ->
      (Key -> Val -> A ->[E] A) -> A ->[E] A

 {## @brief Method to fold right through structure of map
   # @param Function that receives key, value and accumulator
   # @param Accumulator
   # @return Result of applying function on keys
   # and values of map and accumulator
   ##}
  , method foldr : {Val, type A,E} -> T Val ->
      (Key -> Val -> A ->[E] A) -> A ->[E] A

 {## @brief Method that returns list of pairs (key,value)
   ##}
  , method toList : {Val} -> T Val ->[] List (Pair Key Val)

 {## @brief Method that returns list of values
   ##}
  , method toValueList : {Val} -> T Val ->[] List Val

 {## @brief Method that returns list of keys
   ##}
  , method domain : {Val} -> T Val ->[] List Key

 {## @brief Method that maps all values using given function
   ##}
  , method mapVal : {Val, type A, E} -> T Val ->
      (Val ->[E] A) ->[E] T A

 {## @brief Method that maps all (key,value) in a map to (key, func key)
   ##}
  , method mapKey : {Val, type A,E} -> T Val ->
      (Key ->[E] A) ->[E] T A

 {##  @brief Method that applies function to every key and value
   ##}
  , method iter : {Val,E} -> T Val ->
      (Key -> Val ->[E] Unit) ->[E] Unit

 {## @brief Method that joins two maps
   # @param Function that resolves conflicts
   # if maps have the same key
   ##}
  , method union : {Val,E} -> T Val -> T Val ->
      (Key -> Val -> Val ->[E] Val) ->[E] T Val
  
 }

#==============================================================================
# Ordered Map implementation
#==============================================================================

parameter Key
parameter method compare : Key -> Key ->[] Ord

let keyComp (key : Key) (key', _) = key.compare key'

let isEmpty tree =
  match tree with
  | Leaf => True
  | _ => False
  end

let sizeMap tree = size tree

let insert tree (key : Key) val =
  match search (keyComp key) tree [] with
  | (Leaf, zipper) => zipRed (key,val) Leaf Leaf zipper
  | ((Node {color, size, left, right}), zipper) =>
    zip (construct color size left (key,val) right) zipper
  end

let insert' tree (key : Key) val =
  match search (keyComp key) tree [] with
  | (Leaf, zipper) => (zipRed (key,val) Leaf Leaf zipper, False)
  | (Node {color, size, left, right}, zipper) =>
    (zip (construct color size left (key,val) right) zipper, True)
  end

let remove tree (key : Key) =
  match search (keyComp key) tree [] with
  | (Leaf,_) => tree
  | (Node {color, left, right}, zipper) =>
    delete color left right zipper
  end

let remove' tree (key : Key) =
  match search (keyComp key) tree [] with
  | (Leaf,_) => (tree,False)
  | (Node {color, left, right}, zipper) =>
    (delete color left right zipper, True)
  end

let rec member tree (key : Key) =
  match tree with
  | Leaf => False
  | Node {left, value = (key',_), right} =>
    match key.compare key' with
    | Lt => member left key
    | Eq => True
    | Gt => member right key
    end
  end

let rec find tree (key : Key) =
  match tree with
  | Leaf => None
  | Node {left, value = (key', val),  right} =>
    match key.compare key' with
    | Lt => find left key
    | Eq => Some val
    | Gt => find right key
    end
  end

let rec findErr tree (key : Key) =
  match tree with
  | Leaf => ~onError ()
  | Node {left, value = (key', val),  right} =>
    match key.compare key' with
    | Lt => findErr left key
    | Eq => val
    | Gt => findErr right key
    end
  end

let update tree (key : Key) f =
  match search (keyComp key) tree [] with
  | (Leaf, zipper) =>
    match f None with
    | None => tree
    | Some x => zipRed (key,x) Leaf Leaf zipper
    end
  | (Node {color, size, left, value = (_, val), right}, zipper) =>
    match f (Some val) with
    | None => delete color left right zipper
    | Some x => zip (construct color size left (key,x) right) zipper
    end
  end

let rec foldr func tree acc =
  match tree with
  | Leaf => acc
  | Node {left, value = (key, val), right} =>
    let val_right  = foldr func right acc
    let val_middle = func key val val_right in
    foldr func left val_middle
  end

let rec foldl func tree acc =
  match tree with
  | Leaf => acc
  | Node {left, value = (key, val), right} =>
    let val_left   = foldl func left acc
    let val_middle = func key val val_left in
    foldl func right val_middle
  end

let rec map tree func =
  match tree with
  | Leaf => Leaf
  | Node {color, size, left, value = (key,value), right} =>
    let left'  = map left func
    let right' = map right func in
    construct color size left' (key,func value) right'
  end

let rec map2 tree func =
  match tree with
  | Leaf => Leaf
  | Node {color, size, left, value = (key, _), right} =>
    let left'  = map2 left func
    let right' = map2 right func in
    construct color size left' (key, func key) right'
  end

let rec iter tree func =
  match tree with
  | Leaf => ()
  | Node {left, value = (key,value), right} =>
    iter left func;
    func key value;
    iter right func
  end

let rec union (tree1 : Tree (Pair Key _))  tree2 merge =
  match tree1 with
  | Leaf => tree2
  | Node {left = left1, value = (key1,value1), right = right1} =>
    match tree2 with
    | Leaf => tree1
    | _ =>
      let (output,left2,right2) = split (keyComp key1) tree2
      let new_pair =
        match output with
        | None => (key1,value1)
        | Some (_,value2) => (key1, merge key1 value1 value2)
        end
      let left'  = union left1 left2 merge
      let right' = union right1 right2 merge in
      joinVal left' new_pair right'
    end
  end

let toList tree = foldr (fn key value acc => (key, value) :: acc) tree []

let toValueList tree = foldr (fn key value acc => value :: acc) tree []

let domain tree = foldr (fn key value acc => key :: acc) tree []

data MapT Key Val = MapT of Tree (Pair Key Val)

#==============================================================================
# Wrappers
#==============================================================================

let isEmptyT (MapT tree) = isEmpty tree

let sizeMapT (MapT tree) = sizeMap tree

let insertT (MapT tree) (key : Key) val  = MapT (insert tree key val)

let insertChangeT (MapT tree) (key : Key) val =
  let (tree,bool) = insert' tree key val in (MapT tree, bool)

let removeT (MapT tree) (key : Key) = MapT (remove tree key)

let removeChangeT (MapT tree) (key : Key) =
  let (tree,bool) = remove' tree key in (MapT tree, bool)

let memberT (MapT tree) (key : Key) = member tree key

let findT (MapT tree) (key : Key) = find tree key

let findErrT (MapT tree) (key : Key) = findErr tree key

let updateT (MapT tree) (key : Key) f = MapT (update tree key f)

let mapFoldl (MapT tree) func acc = foldl func tree acc

let mapFoldr (MapT tree) func acc = foldr func tree acc

let toListT (MapT tree) = toList tree

let toValueListT (MapT tree) = toValueList tree

let domainT (MapT tree) =  domain tree

let mapVal (MapT tree) func = MapT (map tree func)

let mapKey (MapT tree) func = MapT (map2 tree func)

let iterT (MapT tree) func = iter tree func

let unionT (MapT (tree1 : (Tree (Pair Key _)))) (MapT tree2) merge =
  MapT (union tree1 tree2 merge)

#==============================================================================
# Ordered Map constructor
#==============================================================================

pub let make {Key, method compare : Key -> Key ->[] Ord} = Map {
  T = MapT Key
  , empty = MapT Leaf
  , method isEmpty = isEmptyT
  , method size = sizeMapT
  , method insert = insertT 
  , method insertChange = insertChangeT
  , method remove = removeT 
  , method removeChange = removeChangeT 
  , method member = memberT 
  , method find = findT 
  , method findErr = fn {~onError} => findErrT 
  , method update = updateT 
  , method foldl = mapFoldl
  , method foldr = mapFoldr
  , method toList = toListT
  , method toValueList = toValueListT
  , method domain = domainT
  , method mapVal = mapVal
  , method mapKey = mapKey
  , method iter = iterT
  , method union = unionT 
}

# Papers to read:
# A dichromatic framework for balanced trees. Leo J. Guibas; Robert Sedgewick
# DOI: 10.1109/SFCS.1978.3
# Efficient implementation of red-black trees with split and catenate operations.
# Ron Wein
# Updating a balanced search tree in O(1) rotations. Robert Tarjan
# DOI: 10.1016/0020-0190(83)90099-6
# Similar implementation: 
# https://github.com/standardml/cmlib/blob/master/red-black-tree.sml
