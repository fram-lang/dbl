import Pretty/Core
import /List
import Pretty/Style

## ## The pretty-printer library.

{##
  This module contains a fully featured pretty-printing library.

  The user may find common facilities such as a convenient and highly
  flexible layout choice mechanism. What may come as a surprise is that
  this library also provides uncommon extensions: true horizontal
  concatenation and non-local alignments. These features make it easy
  to print tabular structures.

  Anything printable in this library is represented by the `Doc` type.
  Every operation either modifies a document or combines multiple
  documents into more advanced layouts.

  The primitive way to create a simple, indivisible document is `text`:
  ```text "document"```.
  Text may not contain whitespace characters such as '\n' or '\t'.

  Documents may be combined in three different ways:
    - d1 <> d2  — appends d2 to the last line of d1
    - d1 $$ d2  — places d2 on the next line after d1
    - d1 >+> d2 — places d2 next to d1 (true vertical concatenation)

  The last operation comes with certain limitations, which are explained
  later in the documentation.

  The library also introduces non-local alignments. Consider aligning the
  `=` operator in the following code:

  ```
  let myVar1 = 1000
  let aux = "string"
  ```

  In most pretty-printing libraries, this would require computing the
  exact alignment position before printing. This library automates the
  process:

  ```
  let doc =
    reset
      (text "let myVar" <> shift (text "= 1000"))
      $$ (text "let aux" <> shift (text "= "string""))
  ```

  `shift` annotates the movable part of a document, while `reset`
  collects all such annotations and computes the final alignment.

  Last but not least, the library provides ANSI styling options, which
  are useful for colorizing printed output.
##}

{## The type of the document. ##}
pub type Doc = Core.ODoc

{##
  Text atom, unit of printable text.
  It may not contain white control characters like '\n' or '\t'.
 ##}
pub let (text : String -> Doc) = Core.text

{##
  Empty document.
  The unity of `<>` operation.
 ##}
pub let (empty : Doc) = Core.emptyDoc

{## Creates document out of automatic formatting. ##}
pub let textFmt
  {X, XFmt, method format : {?fmt : XFmt} -> X ->> String }
  (x : X) = text x.format

{## Creates document out of formatting. ##}
pub let textFmtF
  {X, XFmt, method format : {?fmt : XFmt} -> X ->> String }
  (x : X) (f : XFmt) = text (x.format {fmt=f})

{##
  Appends empty line to document.
 ##}
pub let (flush : Doc -> Doc) = fn (d : Doc) => d.flush

{##
  Appends empty line to document.
 ##}
pub method flush = flush

{## Creates document out of single character. ##}
pub let (char : Char -> Doc) = fn (c : Char) => text (charListToStr [c])

{##
  Annotates a document as movable, allowing it to align with other documents.
 ##}
pub let shift {?fill : Char} (d : Doc) = d.shift {?fill}

{##
  Annotates a document as movable, allowing it to align with other documents.
 ##}
pub method shift {?fill : Char} = shift {?fill}

{##
  Catches all moving documents and aligns them. The produced document
  contains no floating parts.
 ##}
pub let (reset : Doc -> Doc) = fn (d : Doc) => d.reset

{##
  Catches all moving documents and aligns them. The produced document
  contains no floating parts.
 ##}
pub method reset = reset

{##
  Puts d2 at the end of last line of d1.
 ##}
pub let (<>) (d1 : Doc) (d2 : Doc) = d1.combine d2

{##
  Puts d2 in the next line, Right after d1.
  Equivalent to `d1.flush <> d2`.
 ##}
pub let ($$) (d1 : Doc) (d2 : Doc) = d1.flush.combine d2

{##
  Places 2 documents in parallel. The last line will always be aligned with
  last line of d2, regardless of actual height of documents.
  Documents may carry shifted documents within but it is not always possible
  to make such concatenation. In such cases, documents will be reset
  before settling.
 ##}
pub let (>+>) (d1 : Doc) (d2 : Doc) = d1.seq d2

{## Standard catenation with shift on second document. ##}
pub let (<>&) (d1 : Doc) (d2 : Doc) = d1 <> d2.shift

{## Vertical catenation with shift on second document. ##}
pub let ($$&) (d1 : Doc) (d2 : Doc) = d1 $$ d2.shift

{## Horizontal catenation with shift on second document. ##}
pub let (>+>&) (d1 : Doc) (d2 : Doc) = d1 >+> d2.shift

{##
  Concatenates `x` and `y` separated by `sep` in single line if possible.
  Otherwise puts `y` in next line with indentation of `n`.
 
  @param ?sep Separator. Defaults to single space.
 ##}
pub let hangWith {?sep : String} (n : Int) (x : Doc) (y : Doc) =
  let sep = sep.unwrapOr " " in
  Core.groupingBy sep [(0, x), (n, y)] : Doc

{##
  Concatenates all documents in single line if possible.
  Otherwise puts each one of them in single line and indents
  with specified value.
 ##}
pub let anyHang {?sep : String} (ds : List (Pair Int Doc)) =
  match ds with
  | [] => text ""
  | [(_, x)] => x
  | ds => Core.groupingBy (sep.unwrapOr " ") ds
  end

{##
  Puts all documents in one line or in separate lines with indentation of 0.
 ##}
pub let (cat : List Doc ->[] Doc) =
  fn xs => Core.groupingBy "" (List.map (fn d => (0, d)) xs)

{##
  Extended `cat` operation that handles enclosing documents and allows
  to specify separator.
 ##}
pub let encloseSep (left : Doc) (right : Doc) (sep : Doc) (ds : List Doc) =
  match ds with
  | [] => left
  | [x] => left <> x
  | d :: ds =>
    cat ((left <> d) :: List.map (fn d => sep <> d) ds)
  end <> right

{## Prints list with break before comma. ##}
pub let (list : List Doc ->[] Doc) =
  encloseSep (text "[") (text "]") (text ",")

{## Prints tuple with break before comma. ##}
pub let (tupled : List Doc ->[] Doc) =
  encloseSep (text "(") (text ")") (text ",")

{## Prints json-like structure with break before semicolon. ##}
pub let (semibraced : List Doc ->[] Doc) =
  encloseSep (text "{") (text "}") (text ";")

{## Performs `<>` with single space separator ##}
pub let (<+>) d1 d2 = d1 <> text " " <> d2

{## Puts d2 right after d1 or in next line ##}
pub let (</>) d1 d2 = hangWith 0 d1 d2

{## Enclosing of a document. ##}
pub let enclose l r d = l <> r <> d

{## Quotes given document. ##}
pub let quote = enclose (text "\"") (text "\"")

{## Same as `cat` but add a single space separator ##}
pub let sep xs = Core.groupingBy " " (List.map (fn d => (0, d)) xs)

{## ` | ` that will extend itself on `<>` and `>+>` catenation ##}
pub let vsep = Core.vsep

{## Clears style for the following document. ##}
pub let clearStyle (doc : Doc) = doc.style Style.Clear

{## Clears style for the following document. ##}
pub method clearStyle = clearStyle

{## Supported colors by Style extension. ##}
pub type Color = Style.Color

pub module Colors
  pub let black   = Style.Black
  pub let red     = Style.Red
  pub let green   = Style.Green
  pub let yellow  = Style.Yellow
  pub let blue    = Style.Blue
  pub let magenta = Style.Magenta
  pub let cyan    = Style.Cyan
  pub let white   = Style.White
end

{## Enables styling of given document. ##}
pub let style
    { ?fg : Color
    , ?bg : Color
    , ?underline : Bool
    , ?strike : Bool }
    (doc : Doc) =
  doc.style (Style.Style {?fg, ?bg, ?underline, ?strike})

{## Enables styling of given document. ##}
pub method style
    { ?fg : Color
    , ?bg : Color
    , ?underline : Bool
    , ?strike : Bool }
    (doc : Doc) =
  doc.style (Style.Style {?fg, ?bg, ?underline, ?strike})

{## Generates single document as string. ##}
pub let generate {?width : Int} = Core.generate {?width}
