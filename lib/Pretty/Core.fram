import open Size
import open Lines
import open /Test
import /List
import /Lazy
import /Stream
import Style

type Layout = Pair Size DocLines

method combine ((x1, y1) : Layout) ((x2, y2) : Layout) =
  (x1.combine x2, y1.combine y2)

method flush ((x, y) : Layout) =
  (x.flush, y.flush)

method reset ((x, y) : Layout) =
  (x.reset, y.reset x.width)

method seq ((x1, y1) : Layout) ((x2, y2) : Layout) =
  let ~onError _ = (runtimeError "Uncomment error safe seq in Core" : Unit) in
  (x1.seq x2, y1.seq y2 x1.getAlign)

# TODO Uncomment.
# Commented due to huge type-checker slow down

#method seq (l1 : Layout) (l2 : Layout) =
#  let mkSeq {~onError} ((x1, y1) : Layout) ((x2, y2) : Layout) =
#    (x1.seq x2, y1.seq y2 x1.getAlign)
#  let gentle =
#    handle
#      ~onError = effect _ => None
#      return c => Some c
#    in mkSeq l1 l2 in
#  match gentle with
#  | Some c => c
#  | None =>
#    let ~onError _ = impossible () in
#    mkSeq (l1.reset) (l2.reset)
#  end

method style ((x, y) : Layout) (sty : Style.Style) = (x, y.style sty)

pub data ODoc = ODoc of (Int ->[] Stream.Stream Layout)

pub let text str = ODoc (fn _ => Stream.singleton (textSize str, textLines str))
pub let emptyDoc = text ""

let textLayout str = (textSize str, textLines str)
let spaces n = textLayout (mkStr " " n)

pub let (<>) {X, method combine : X -> X ->[] X} (x : X) = x.combine
pub let ($$) {X, method combine : X -> X ->[] X, method flush : X ->[] X} (x : X) =
  x.flush.combine

let paretoSelector
  {X : type}
  (poset : X -> X ->[] Bool)
  (seq : Stream.Stream X) = 
    let rec iter (mins : List X) (seq : Stream.Stream X) () =
      match seq.uncons with
      | None => Stream.empty
      | Some (x, seq) =>
        match List.findIndex (fn y => poset y x) mins with
        | Some _ => iter mins seq ()
        | None => Stream.lazyCons x (iter (x :: mins) seq)
        end
      end in
    Stream.lazyStream (iter [] seq)

let rec mergeOn
  sel
  (xs : Stream.Stream _)
  (ys : Stream.Stream _) = Stream.lazyStream (fn _ =>
    match xs.uncons with
    | None => ys
    | Some(x, xs') => match ys.uncons with
      | None => xs
      | Some (y, ys') =>
        if sel x y then
          Stream.cons x (mergeOn sel xs' ys)
        else
          Stream.cons y (mergeOn sel xs ys')
      end
    end)

let rec mergeAllOn sel (xss : Stream.Stream (Stream.Stream _)) =
  Stream.lazyStream (fn _ =>
    match xss.uncons with
    | None => Stream.empty
    | Some (x, ys) => mergeOn sel x (mergeAllOn sel ys)
    end)

let bestOn ord poset xss =
  paretoSelector poset (mergeAllOn ord xss)

let maxWidth (w : Size) =
  match w.reset with
  | Size {width=SLast (SFix {width})} => width
  | _ => impossible ()
  end

# assumes non-empty input and returns non empty output
let quasifilter {X} (pred : X ->[] Bool) (ord : X -> X ->[] Bool) (ws : Stream.Stream X) =
  Stream.lazyStream (fn _ =>
    match ws.uncons with
    | None => Stream.empty
    | Some (x, xs') =>
      if Stream.isEmpty xs' then
        Stream.singleton x
      else
       (let fted = Stream.filter pred ws in
        match fted >.uncons with
        | None =>
          let el = Stream.foldr1 (fn x y => if ord x y then x else y) ws in
          Stream.singleton el
        | Some _ => fted
        end)
    end)

let discardInvalid (w : Int) =
  quasifilter
    (fn s => maxWidth (fst s) < w)
    (fn x y => maxWidth (fst x) <= maxWidth (fst y))

let (>>=) (xs : Stream.Stream _) f = Stream.bind f xs

pub method combine (ODoc xs) (ODoc ys) = ODoc (fn w =>
  let ds = xs w >>= (fn x =>
    Stream.singleton (discardInvalid w (ys w >>= (fn y => Stream.singleton (x <> y))))) in
  bestOn
    (fn x y => ord (fst x) (fst y))
    (fn x y => poset (fst x) (fst y))
      ds)

pub let groupingBy (sep : String) (ms : List (Pair Int ODoc)) =
  match ms with
  | [] => emptyDoc
  | ms => ODoc (fn w =>
    let (mws : List (Pair Int (Stream.Stream Layout)))
      = List.map (fn (x, ODoc d) => (x, d w)) ms in
    let (init, (_, last)) = List.initLast mws in
    let (hcat : List (Stream.Stream Layout))
      = List.map (fn x => onlySingleLine (snd x)) init + [last] in
    let (vcat : List (Stream.Stream Layout))
      = List.map (fn (i, x) => Stream.map (fn x => spaces i <> x) x) mws in
    let hor = discardInvalid w
      (List.foldr1
        (fn xs ys => xs >>= (fn x =>
                     ys >>= (fn y =>
                     Stream.singleton (x <> textLayout sep <> y))))
        hcat) in
    let ver =
      List.foldr1
        (fn xs ys =>
          bestOn 
            (fn x y => ord (fst x) (fst y))
            (fn x y => poset (fst x) (fst y))
            (xs >>= (fn x =>
            Stream.singleton (ys >>= (fn y =>
               Stream.singleton (x $$ y))))))
        vcat in
    let ls = bestOn
      (fn x y => ord (fst x) (fst y))
      (fn x y => poset (fst x) (fst y))
      (Stream.fromList [hor, ver]) in
    (ls : Stream.Stream Layout)) # discardInvalid w ls)
  end

pub method flush (ODoc xs) = ODoc (fn w =>
  xs w >.map (fn ((x, y) : Layout) => (x.flush, y.flush)))

pub method reset (ODoc xs) = ODoc (fn w =>
  xs w >.map (fn ((x, y) : Layout) => (x.reset, y.reset x.width)))

pub method shift (ODoc xs) = ODoc (fn w =>
  xs w >.map (fn ((x, y) : Layout) => (x.shift, y.shift)))

pub method seq {~__line__, ~__file__} (ODoc xs) (ODoc ys) = ODoc (fn w =>
  bestOn
    (fn x y => ord (fst x) (fst y))
    (fn x y => poset (fst x) (fst y))
      (xs w >.map
        (fn (x : Layout) =>
          discardInvalid w (ys w >.map (fn y => x.seq y)))))

pub method style (ODoc xs) (sty : Style.Style) = ODoc (fn w =>
  xs w >. map (fn (l : Layout) => l.style sty))

pub let (vsep : ODoc) = ODoc (fn _ =>
  Stream.singleton (textSize " | ", vsep))

pub let generate {?width : Int} (ODoc xs) =
  let width = width.unwrapOr 80 in
  match xs width >.uncons with
  | None => runtimeError "Layout selection error"
  | Some (layout, _) =>
    let (_, lines) = layout.reset in
    let lines = lines.force in
    (unlines width lines : String)
  end

pub let generateDebug width (ODoc xs) = match xs width >.uncons with
  | None => impossible ()
  | Some (layout, _) =>
    let layout = layout.reset in
    let (size, lines) = layout in
    printStrLn size.format;
    printStrLn "";
    printStrLn (debugLines lines.force);
    printStrLn (unlines width lines.force)
  end

pub let runTests () = testSuite "/Pretty/Core" (fn _ =>
  testCase "`paretoSelector` empty" (fn _ =>
    let (iStr : Stream.Stream Int) = Stream.empty in
    assertEq iStr (paretoSelector (fn x y => False) iStr));
  
  testCase "`paretoSelector` singleton" (fn _ =>
    [0, 10, 50, 2137].iter (fn x =>
    assertEq (Stream.singleton x) (paretoSelector (fn x y => False) (Stream.singleton x))));
  
  let cmpInts (x : Int) (y : Int) = x <= y in

  let mkS = Stream.fromList in

  testCase "`paretoSelector` pairs" (fn _ =>
    assertEq (mkS [10])     (paretoSelector cmpInts (mkS [10, 20]));
    assertEq (mkS [20, 10]) (paretoSelector cmpInts (mkS [20, 10]));
    assertEq (mkS [10])     (paretoSelector cmpInts (mkS [10, 10])));

  testCase "`paretoSelector` many" (fn _ =>
    assertEq (mkS [10])         (paretoSelector cmpInts (mkS [10, 20, 30, 40, 50, 60]));
    assertEq (mkS [30, 20, 10]) (paretoSelector cmpInts (mkS [30, 20, 10]));
    assertEq (mkS [30, 10, 5])  (paretoSelector cmpInts (mkS [30, 10, 10, 20, 5])));

  testCase "`mergeOn` empty" (fn _ =>
    assertEq (mkS []) (mergeOn cmpInts (mkS []) (mkS [])));
  
  testCase "`mergeOn` singletons" (fn _ =>
    assertEq (mkS [1, 2]) (mergeOn cmpInts (mkS [2]) (mkS [1]));
    assertEq (mkS [1, 2]) (mergeOn cmpInts (mkS [1]) (mkS [2])));
  
  testCase "`mergeOn` many" (fn _ =>
    assertEq
      (mkS [1, 2, 3, 4, 5, 6, 7, 8])
      (mergeOn cmpInts (mkS [1, 3, 5, 7]) (mkS [2, 4, 6, 8]));
    assertEq
      (mkS [1, 2, 3, 4, 5, 6])
        (mergeOn cmpInts (mkS [1, 2, 5]) (mkS [3, 4, 6])));
  
  testCase "`mergeAllOn` empty" (fn _ =>
    assertEq (mkS []) (mergeAllOn cmpInts (mkS [])));
  
  testCase "`mergeAllOn` empties" (fn _ =>
    assertEq (mkS []) (mergeAllOn cmpInts (mkS [mkS [], mkS [], mkS []])));
  
  testCase "`mergeAllOn` singletons" (fn _ =>
    assertEq (mkS [1, 2, 3]) (mergeAllOn cmpInts (mkS [mkS [2], mkS [1], mkS [3]]));
    assertEq (mkS [1, 2, 3]) (mergeAllOn cmpInts (mkS [mkS [3], mkS [2], mkS [1]])));
  
  testCase "`mergeAllOn` manies" (fn _ =>
    assertEq
      (mkS [1, 2, 3, 4, 5, 6, 7, 8])
      (mergeAllOn cmpInts (mkS [mkS [1, 3], mkS [], mkS [2, 4, 6, 8], mkS [5, 7]])));
  
  let ordPairs (x1, y1) (x2, y2) =
    (x1 : Int) < x2 || (x1 == x2 && (y1 : Int) < y2) in

  let posetPairs (x1, y1) (x2, y2) =
    (((x1 : Int) <= x2) && ((y1 : Int) <= y2)) in

  let pairEq (x1, y1) (x2, y2) =
    ((x1 : Int) == x2 && (y1 : Int) == y2) in

  method equal = pairEq in

  testCase "`bestOn` empty" (fn _ =>
    assertEq (mkS []) (bestOn ordPairs posetPairs (mkS [])));
  
  testCase "`bestOn` empties" (fn _ =>
    assertEq (mkS []) (bestOn ordPairs posetPairs (mkS [mkS [], mkS [], mkS []])));
  
  testCase "`bestOn` singletons" (fn _ =>
    assertEq
      (mkS [(1, 1), (3, 0)])
      (bestOn ordPairs posetPairs (mkS [mkS [(2, 1)], mkS [(1, 1)], mkS [(3, 0)]]));
    assertEq
      (mkS [(5, 6)])
      (bestOn ordPairs posetPairs (mkS [mkS [(5, 6)], mkS [(6, 7)], mkS [(5, 7)]])));
  
  testCase "`bestOn` manies" (fn _ =>
    assertEq
      (mkS [(1, 3), (6, 0)])
      (bestOn ordPairs posetPairs (mkS [mkS [(1, 3)], mkS [], mkS [(2, 4), (6, 0)], mkS [(5, 7)]])));
  
  testCase "`quasifilter` singleton" (fn _ =>
    assertEq (mkS [1]) (quasifilter (fn _ => False) cmpInts (mkS [1]));
    assertEq (mkS [1]) (quasifilter (fn _ => True)  cmpInts (mkS [1])));
  
  testCase "`quasifilter` filters" (fn _ =>
    assertEq (mkS [1, 2, 1]) (quasifilter (fn x => 5 > x) cmpInts (mkS [1, 10, 6, 2, 1]));
    assertEq (mkS [6, 7]) (quasifilter (fn x => 4 % x == 4)  cmpInts (mkS [1, 6, 7, 2])));

  testCase "`quasifilter` selects minimum" (fn _ =>
    assertEq (mkS [0]) (quasifilter (fn x => False) cmpInts (mkS [2, 1, 3, 7, 0, 42]));
    assertEq
      (mkS [(0, 0)])
      (quasifilter (fn x => False) ordPairs (mkS [(2, 1), (1, 2), (3, 3), (0, 0)])));
  
  ())
