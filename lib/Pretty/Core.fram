import open Size
import open Lines
import /List
import /Lazy
import /Stream
import Style

let ~onError () = runtimeError "PrettyPrinter - internal error"

type Layout = Pair Size DocLines

method combine ((x1, y1) : Layout) ((x2, y2) : Layout) =
  (x1.combine x2, y1.combine y2)

method flush ((x, y) : Layout) =
  (x.flush, y.flush)

method reset ((x, y) : Layout) =
  (x.reset, y.reset x.width)

method seq (l1 : Layout) (l2 : Layout) =
  let mkSeq {~onError : Unit ->> Unit} ((x1, y1) : Layout) ((x2, y2) : Layout) =
    (x1.seq x2, y1.seq y2 x1.getAlign)
  let gentle =
    handle
      ~onError = effect _ => None
      return c => Some c
    in mkSeq l1 l2 in
  match gentle with
  | Some c => c
  | None =>
    let ~onError _ = impossible () in
    mkSeq (l1.reset) (l2.reset)
  end

method style ((x, y) : Layout) (sty : Style.Style) = (x, y.style sty)

pub data ODoc = ODoc of (Int ->[] Stream.Stream Layout)

pub let text str = ODoc (fn _ => Stream.singleton (textSize str, textLines str))
pub let emptyDoc = text ""

let textLayout str = (textSize str, textLines str)
let spaces n = textLayout (replicate " " n)

pub let (<>) {X, method combine : X -> X ->[] X} (x : X) = x.combine
pub let ($$) {X, method combine : X -> X ->[] X, method flush : X ->[] X} (x : X) =
  x.flush.combine

pub let paretoSelector
  {X : type}
  (poset : X -> X ->[] Bool)
  (seq : Stream.Stream X) = 
    let rec iter (mins : List X) (seq : Stream.Stream X) () =
      match seq.uncons with
      | None => Stream.empty
      | Some (x, seq) =>
        match List.findIndex (fn y => poset y x) mins with
        | Some _ => iter mins seq ()
        | None => Stream.cons x (Stream.lazyStream ((iter (x :: mins) seq)))
        end
      end in
    Stream.lazyStream (iter [] seq)

pub let rec mergeOn
  sel
  (xs : Stream.Stream _)
  (ys : Stream.Stream _) = Stream.lazyStream (fn _ =>
    match xs.uncons with
    | None => ys
    | Some(x, xs') => match ys.uncons with
      | None => xs
      | Some (y, ys') =>
        if sel x y then
          Stream.cons x (mergeOn sel xs' ys)
        else
          Stream.cons y (mergeOn sel xs ys')
      end
    end)

pub let rec mergeAllOn sel (xss : Stream.Stream (Stream.Stream _)) =
  Stream.lazyStream (fn _ =>
    match xss.uncons with
    | None => Stream.empty
    | Some (x, ys) => mergeOn sel x (mergeAllOn sel ys)
    end)

pub let bestOn ord poset xss =
  paretoSelector poset (mergeAllOn ord xss)

let maxWidth (w : Size) =
  match w.reset with
  | Size {width=SLast (SFix {width})} => width
  | _ => impossible ()
  end

# assumes non-empty input and returns non empty output
pub let quasifilter {X} (pred : X ->[] Bool) (ord : X -> X ->[] Bool) (ws : Stream.Stream X) =
  Stream.lazyStream (fn _ =>
    match ws.uncons with
    | None => Stream.empty
    | Some (x, xs') =>
      if Stream.isEmpty xs' then
        Stream.singleton x
      else
       (let fted = Stream.filter pred ws in
        match fted >.uncons with
        | None =>
          let el = Stream.foldRight1Err (fn x y => if ord x y then x else y) ws in
          Stream.singleton el
        | Some _ => fted
        end)
    end)

let discardInvalid (w : Int) =
  quasifilter
    (fn s => maxWidth (fst s) <= w)
    (fn x y => maxWidth (fst x) <= maxWidth (fst y))

let (>>=) (xs : Stream.Stream _) f = Stream.concatMap f xs

pub method combine (ODoc xs) (ODoc ys) = ODoc (fn w =>
  let ds = xs w >>= (fn x =>
    Stream.singleton (discardInvalid w (ys w >>= (fn y => Stream.singleton (x <> y))))) in
  bestOn
    (fn x y => ord (fst x) (fst y))
    (fn x y => poset (fst x) (fst y))
      ds)

pub let groupingBy (sep : String) (ms : List (Pair Int ODoc)) =
  match ms with
  | [] => emptyDoc
  | ms => ODoc (fn w =>
    let (mws : List (Pair Int (Stream.Stream Layout)))
      = List.map (fn (x, ODoc d) => (x, d w)) ms in
    let (init, (_, last)) = List.dropTakeLast mws >.unwrapErr in
    let (hcat : List (Stream.Stream Layout))
      = List.map (fn x => onlySingleLine (snd x)) init + [last] in
    let (vcat : List (Stream.Stream Layout))
      = List.map (fn (i, x) => Stream.map (fn x => spaces i <> x) x) mws in
    let hor = discardInvalid w
      (List.foldRight1
        (fn xs ys => xs >>= (fn x =>
                     ys >>= (fn y =>
                     Stream.singleton (x <> textLayout sep <> y))))
        hcat).unwrapErr in
    let ver =
      List.foldRight1
        (fn xs ys =>
          bestOn 
            (fn x y => ord (fst x) (fst y))
            (fn x y => poset (fst x) (fst y))
            (xs >>= (fn x =>
            Stream.singleton (ys >>= (fn y =>
               Stream.singleton (x $$ y))))))
        vcat >.unwrapErr
    let ls = bestOn
      (fn x y => ord (fst x) (fst y))
      (fn x y => poset (fst x) (fst y))
      (Stream.fromList [hor, ver]) in
    discardInvalid w ls)
  end

pub method flush (ODoc xs) = ODoc (fn w =>
  xs w >.map (fn ((x, y) : Layout) => (x.flush, y.flush)))

pub method reset (ODoc xs) = ODoc (fn w =>
  xs w >.map (fn ((x, y) : Layout) => (x.reset, y.reset x.width)))

pub method shift (ODoc xs) = ODoc (fn w =>
  xs w >.map (fn ((x, y) : Layout) => (x.shift, y.shift)))

pub method seq {~__line__, ~__file__} (ODoc xs) (ODoc ys) = ODoc (fn w =>
  bestOn
    (fn x y => ord (fst x) (fst y))
    (fn x y => poset (fst x) (fst y))
      (xs w >.map
        (fn (x : Layout) =>
          discardInvalid w (ys w >.map (fn y => x.seq y)))))

pub method style (ODoc xs) (sty : Style.Style) = ODoc (fn w =>
  xs w >. map (fn (l : Layout) => l.style sty))

pub let (vsep : ODoc) = ODoc (fn _ =>
  Stream.singleton (textSize " | ", vsep))

pub let generate {?width : Int} (ODoc xs) =
  let width = width.unwrapOr 80 in
  match xs width >.uncons with
  | None => runtimeError "Layout selection error"
  | Some (layout, _) =>
    let (_, lines) = layout.reset in
    let lines = lines.force in
    (unlines width lines : String)
  end

pub let generateDebug width (ODoc xs) =
  let rec iter (xs : Stream.Stream Layout) =
    match xs.uncons with
    | None => ()
    | Some (layout, tail) =>
      let layout = layout.reset in
      let (size, lines) = layout in
      printStrLn size.toString;
      printStrLn "";
      printStrLn (debugLines lines.force);
      printStrLn (unlines width lines.force);
      iter tail
    end in
  iter (xs width)
