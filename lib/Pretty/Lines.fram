import open /Lazy
import /List
import Size
import open Style
import /Stream

type SList = Size.SList

{##
  Data structure representing unformed lines to display
 ##}
data rec L =
  ## Line catenation
  | LCat of L, L
  ## Line prefixed with `n` spaces
  | LFill of Int, L
  ## Any string
  | LStr of String
  ## Empty line
  | LEmpty
  ## Singular shift, exact amount of spaces
  ## will be decided during generation
  | LShift of Char, L
  ## Reset node, contains Shift List to allocate
  ## shifts during rendering
  | LReset of SList, L

  ## Multi-level relative shift. Jumps by n shifts and 
  ## inserts `static` amount of spaces. Exact shift will be resolved
  ## striong generation
  | LJump of {n : Int, static : Int}, L, L

  | LStyled of Style, L

method toString {?fmt : Unit} (self : L) =
  let rec iter l xs = match l with
    | LCat l1 l2 => iter l1 (" " :: iter l2 xs)
    | LFill n l => "f\{n}" :: xs
    | LStr s => s.toString :: xs
    | LEmpty => "e" :: xs
    | LShift _ l => "&(" :: (iter l (")" :: xs))
    | LReset slist l => "*(" :: (iter l (")" :: xs))
    | LJump {n, static} l1 l2 =>
      "{" :: iter l1 (" >\{n}+\{static}> " :: iter l2 ("}" :: xs))
    | LStyled _ l => iter l xs
    end
  in strListCat (iter self [])     

data Line = {fill : L, str : L}

method toString {?fmt : Unit} (Line {fill, str}) =
  "Line {fill = \{fill},\n      line = \{str}}"

pub let emptyLine = Line {fill = LEmpty, str = LEmpty}

type Lines = List Line

method flush (lines : Lines) = lines + [emptyLine]

method shift {?fill : Char} (lines : Lines) =
  let f = fill.unwrapOr ' ' in
  List.map (fn (Line {fill, str}) =>
    Line {fill = LShift ' ' fill, str = LShift f str}) lines

method reset (lines : Lines) slist = 
  List.map (fn (Line {fill, str}) =>
    Line {fill = LReset slist fill, str = LReset slist str}) lines

method combine (xs : Lines) (ys : Lines) =
  let rec iter xs = match xs with
    | [] => ys
    | [Line {fill, str}] =>
      match ys with
      | [] => [Line {fill, str}]
      | Line {fill=fill', str=str'} :: ys =>
        Line {fill=LCat fill fill', str = LCat str str'}
          :: List.map (fn (y : Line) =>
            Line{fill = LCat fill y.fill, str=LCat fill y.str}) ys
      end
    | x :: xs => x :: iter xs
    end in
  iter xs

method seq (xs : Lines) (ys : Lines) ((n, static) : Pair Int Int) =
  let rec iter (xs : Lines) (ys : Lines) = match (xs, ys) with
    | [x], y :: ys =>
      Line
        { fill = LJump {n, static} x.fill y.fill
        , str = LJump {n, static} x.str y.str } ::
      List.map
        (fn (Line {fill, str}) =>
          Line
            { fill = LJump {n, static} x.fill fill
            , str = LJump {n, static} x.fill str })
        ys
    
    | x :: xs, [y] =>
      Line
        { fill = LJump {n, static} x.fill y.fill
        , str = LJump {n, static} x.str y.str } ::
      List.map
        (fn (Line {fill, str}) =>
          Line
            { fill = LJump {n, static} fill y.fill
            , str = LJump {n, static} str y.fill })
        xs
    
    | (x :: xs, y :: ys) =>
      Line
        { fill = LJump {n, static} x.fill y.fill
        , str = LJump {n, static} x.str y.str } ::
      iter xs ys
    
    | _ => impossible ()
    end in
  iter xs ys

method style (xs : Lines) (sty : Style) =
  List.map (fn (Line {fill, str}) => Line {fill, str = LStyled sty str}) xs

type LineState = Pair (Pair Int (List Int)) Int

data State E =
  { put : LineState ->[E] Unit
  , get : Unit ->[E] LineState }

let stateH (w : Int) =
  handler
    State
      { put = effect s / r => fn _ => r () s
      , get = effect _ / r => fn s => r s s }
      return x => fn _ => x
      finally c => c (0, [w], 0)
  end

method move {E} (st : State E) (w : Int) = 
  let (p, sh, x) = st.get () in
  st.put (p + w, sh, x)

method getShift {E} (st : State E) =
  let (p, sh, x) = st.get () in
  match sh with
  | [] => runtimeError "Empty shift state"
  | s :: sh =>
    assert {msg="Cursor is past allocated column: \{p} vs \{s}"}
      (p <= s);
    let diff = s - p in
    st.put (s, sh, x + 1);
    diff
  end

method getCurrentPosition {E} (st : State E) =
  let (p, _, x) = st.get () in (p, x)

method putShifts {E} (st : State E) (sl : SList) =
  let (p, sh, _) = st.get () in
  let rec iter (p : Int) sl = match sl with
    | Size.SLast tl => iter p tl
    | Size.SFix {width} => [width + p]
    | Size.SShift {width} tl => width + p :: iter (width + p) tl
    end in
  st.put (p, iter p sl, 0)

method calculateAlignment {E} (st : State E) (n : Int) (static : Int) =
  let (p, sh, x) = st.get () in
  if n == 0 then
    (x, p + static)
  else
    match List.drop (n - 1) sh with
    | [] => runtimeError "Alignment - not enought shifts"
    | d :: _ =>
      (n, d + static)
    end

method getAlignment {E} (st : State E) (nth : Int) (column : Int) =
  let (p, sh, x) = st.get () in
  st.put (column, List.drop (nth - x) sh, nth);
  column - p

let rec genL {~h : State _, ~s : Stylist _} (self : L) = match self with
  | LEmpty => ""
  | LStr str => ~h.move str.length; str
  | LShift fill tl =>
    let s = ~h.getShift in
    replicate fill.toString s + genL tl
  | LReset sl tl =>
    let (_, sh, n) = ~h.get () in
    ~h.putShifts sl;
    let res = genL tl in
    let (p, _, _) = ~h. get () in
    ~h.put (p, sh, n);
    res
  | LFill i tl =>
      ~h.move i;
      replicate " " i + genL tl
  | LCat l1 l2 => genL l1 + genL l2
  | LJump {n, static} l1 l2 =>
    let (nth, column) = ~h.calculateAlignment n static in
    let s1 = genL l1 in
    let jmp = ~h.getAlignment nth column in
    let s2 = genL l2 in
    s1 + replicate " " jmp + s2
  | LStyled sty l =>
    let opn = ~s.pushStyle sty
    let line = genL l
    let cls = ~s.popStyle () in
    opn + line + cls
  end

pub let rec debugLines (xs : Lines) =
  match xs with
  | [] => ""
  | x :: xs => (x : Line).toString + "\n" + debugLines xs
  end

pub let unlines w (xs : Lines) =
  let strs = List.map (fn (x : Line) =>
    handle ~s with styleH in
    handle ~h with stateH w in genL x.str) xs in
  let rec fold (xs : List String) = match xs with
    | [] => ""
    | x :: xs => x + "\n" + fold xs
    end in
  fold strs

pub let onlySingleLine = Stream.takeWhile
  (fn (Size.Size {height}, _) => height == 0)

pub type DocLines = Lazy Lines

pub let textLines (str : String) =
  (lazy (fn _ =>
    [Line {fill = LFill str.length LEmpty, str = LStr str}]) : DocLines)

pub method flush (lines : DocLines) =
  lazy (fn _ => lines.force.flush)

pub method reset (lines : DocLines) slist =
  lazy (fn _ => lines.force.reset slist)

pub method shift {?fill : Char} (lines : DocLines) =
  lazy (fn _ => lines.force.shift {?fill})

pub method combine (lines1 : DocLines) (lines2 : DocLines) =
  lazy (fn _ => lines1.force.combine lines2.force)

pub method seq (lines1 : DocLines) (lines2 : DocLines) (align : Pair Int Int) =
  lazy (fn _ => lines1.force.seq lines2.force align)

pub method style (lines : DocLines) (sty : Style) =
  lazy (fn _ => lines.force.style sty)

pub let (vsep : DocLines) =
  lazy (fn _ => [Line {fill = LStr " | ", str = LStr " | "}])
