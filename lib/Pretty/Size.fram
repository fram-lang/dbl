import /List
import open Lazy

{##
  Shift list aka `SList' 
  
  Structure stores width as a list of floating elements.
  Floating aka floating elements will align globally with other floating
  elements.

  `SFix' represents singular unmoveable object.

  Each `SShift' stores an information about floating elements that
  are willing to globally align with others. 

  The `SLast' node is a label that indicates a line where <> will attach
  foramatted text. In every Size object there is exactly one SLast node.
 ##}

pub data rec SList =
  | SFix   of {width : Int} 
  | SShift of {width : Int, dangle : Int}, SList
  | SLast  of {width : Int}, SList

method rec toString {?prec : Int, ?fmt : Unit} (self : SList) =
   match self with
  | SFix {width} => "SF {width=\{width}}"
  | SShift {width, dangle} tl =>
    "SS {width=\{width}, dangle=\{dangle}} (\{tl})"
  | SLast {width} tl => "SL {width=\{width}} (\{tl})"
  end

pub method rec equal (s1 : SList) (s2 : SList) =
  match (s1, s2) with
  | SFix {width=w1}, SFix {width=w2} => w1 == w2
  | SShift {width=w1, dangle=d1} s1, SShift {width=w2, dangle=d2} s2 =>
      w1 == w2 && d1 == d2 && s1 == s2
  | SLast {width=w1} s1, SLast {width=w2} s2 => w1 == w2 && s1 == s2
  | _ => False
  end

{## Fast reset calculation ##}
pub method reset (xs : SList) =
  let rec iter xs =
    match xs with
    | SFix {width} => (width, 0)
    | SLast {width} tl =>
      let (fix, _) = iter tl in
      (fix, width)
    | SShift {width, dangle} tl =>
      let (fix, last) = iter tl
      let tot = max dangle (width + fix) in
      (tot, width + last)
    end
  in
  iter xs

{##
  Structure stores a size of a given thunk of formatted text.

  Height is given explicitly, width is stored as a `shift list'.
 ##}
pub data Size =
  { width       : SList
  , height      : Int
  , fastCompare : Lazy (Pair Int Int)
  }

pub method toString (self : Size) =
  "Size {width = \{self.width}, height = \{self.height}}"

pub method equal (w1 : Size) (w2 : Size) =
  w1.width == w2.width && w1.height == w2.height

{## Constructs Size object for a singular string ##}
pub let textSize (s : String) =
  let width = s.length in
  Size { width=SLast {width} (SFix {width})
       , height=0
       , fastCompare = pureLazy (width, width)
       }

{## Empty width ##}
pub let emptySize = textSize ""

{## Inserts newline ##}
pub method flush (Size {width, height, fastCompare}) =
  let rec dropL w = match w with
    | SShift {width, dangle} tl => SShift {width, dangle} (dropL tl)
    | SLast tl => tl
    | SFix => impossible ()
    end in
  Size { width = SLast {width=0} (dropL width)
       , height = height + 1
       , fastCompare
       }

{##
  Calculates size after <> operation as such:

  _____________         _____________        
  |           | >shift> |           | >shift> |.....|
  |         __|         |         __|        
  |________|            |________|   <> _____________        
                                        |           | >....>
                                        |         __|
                                        |________|                
 ##}
pub method combine (w1 : Size) (w2 : Size) =
  let height = w1.height + w2.height in

  # Moves a shift list by a fixed amount
  let rec moveBy w xs = match xs with
    | SLast {width} tl => SLast {width=width + w} (moveBy w tl)
    | SFix {width} => SFix {width=width + w}
    | SShift {width, dangle} tl =>
        SShift {width=width + w, dangle=dangle + w} tl 
    end in

  # Handles paraller join of two given shift list
  # By assumpion w1 does NOT contain SLast label
  let rec combineWs (w1 : SList) (w2 : SList) = 
    match (w1, w2) with
    ## regular elements

    # take maximum over elements
    | SFix {width=w1}, SFix {width=w2} => SFix {width=max w1 w2}
    | SShift {width=w1, dangle=d1} s1, SShift {width=w2, dangle=d2} s2 =>
      SShift {width=max w1 w2, dangle=max d1 d2} (combineWs s1 s2)
    
    # add SFix as a dangling width
    | SFix {width=w1}, SShift {width=w2, dangle=d} s =>
      SShift {width=w2, dangle=max d w1} s    
    | SShift {width=w1, dangle=d} s, SFix {width=w2} =>
      SShift {width=w1, dangle=max d w2} s    
    
    ## right last - copy last and continue as usual
    # | SShift {width=w1, dangle} s, SLast {width=l} (SFix {width=w2}) =>
    #   SLast {width=l} (SShift {width=max w1 w2})
    | s1, SLast {width} s2 => SLast {width} (combineWs s1 s2)

    # left last and anything else
    | _ => impossible ()
    end in

  # The starting point of algorithm
  # The <> catenation happens at `SLast' node of w1, thus
  # width is copied up until `SLast' and then combineWs
  # operation is permormed. The SLast label will be
  # propagated from w2
  let rec copyTillL (w1 : SList) (w2 : SList) =
    match w1 with
    | SFix => impossible ()
    | SShift {width, dangle} tl => SShift {width, dangle} (copyTillL tl w2)
    | SLast {width} tl => combineWs tl (moveBy width w2)
    end in
  
  let width = copyTillL w1.width w2.width in
  Size {width, height, fastCompare = lazy (fn _ => width.reset)}

{## Fixes shifts in place and propagates fixed width information ##}
pub method reset (w : Size) =
  let (fix, last) = w.fastCompare.force in
  Size { width = SLast {width=last} (SFix {width=fix})
       , height = w.height
       , fastCompare = w.fastCompare }

{## Adds an empty shift. ##}
pub method shift (Size {width, height, fastCompare}) =
  Size { width = SShift {width=0, dangle=0} width
       , height
       , fastCompare
       }

{##
  Calculates true vertiacal catenation.

  To simplify calculation, vcat can performed only if dangling width
  of every SShift node of w1 is 0. To preserve monoid like behaviour
  of this operation, same restriction have been put on w2.
##}
pub method seq {~onError} (w1 : Size) (w2 : Size) =
  let rec checkAssumpions (sh : SList) = match sh with
    | SLast tl => checkAssumpions tl
    | SFix {width} => width
    | SShift {width, dangle} tl =>
      let pth = width + checkAssumpions tl in
      if dangle > pth then
        (let _ = ~onError () in ());
      pth
      end in
  let _ = checkAssumpions w1.width
  let _ = checkAssumpions w2.width

  let rec join s = match s with
    | SLast tl => join tl
    | SShift {width, dangle} tl => SShift {width, dangle} (join tl)
    | SFix {width=w1} => match w2.width with
      | SLast {width=l} (SFix {width=w2}) =>
        SLast {width=l + w1} (SFix {width=w1 + w2})
      | SLast {width=l} (SShift {width=w2} tl) =>
        SLast {width=l + w1} (SShift {width=w1 + w2, dangle=0} tl)
      | SShift {width=w2} tl => SShift {width=w1 + w2, dangle=0} tl
      | _ => impossible ()
      end
    end in
  let width = join w1.width in
  Size { height = max w1.height w2.height
       , width
       , fastCompare = lazy (fn _ => width.reset)
       }

pub method getAlign (w : Size) =
  let rec iter (w : SList) = 
    match w with
    | SLast tl => iter tl
    | SShift tl => let (x, y) = iter tl in (x + 1, y)
    | SFix {width} => (0, width)
    end
  in iter w.width

pub let poset (w1 : Size) (w2 : Size) =
  let (m1, l1) = w1.fastCompare.force
  let (m2, l2) = w2.fastCompare.force in
  m1 <= m2 && w1.height <= w2.height && l1 <= l2

pub let ord (w1 : Size) (w2 : Size) =
  if w1.height < w2.height then
    True
  else if w1.height > w2.height then
    False
  else (
    let (m1, l1) = w1.fastCompare.force
    let (m2, l2) = w2.fastCompare.force in
    m1 < m2 || (m1 == m2 && l1 < l2))

pub let maxWidth (w : Size) =
  w.fastCompare.force.fst
