import AnsiTerminal as Term

pub data Color =
  | Black
  | Red
  | Green
  | Yellow
  | Blue
  | Magenta
  | Cyan
  | White

method equal (c1 : Color) (c2 : Color) =
  match (c1, c2) with
  | Black,   Black   => True
  | Red,     Red     => True
  | Green,   Green   => True
  | Yellow,  Yellow  => True
  | Blue,    Blue    => True
  | Magenta, Magenta => True
  | Cyan,    Cyan    => True
  | White,   White   => True
  | _,       _       => False
  end

method toAnsi (color : Color) =
  match color with
  | Black   => Term.Font.Black
  | Red     => Term.Font.Red
  | Green   => Term.Font.Green
  | Yellow  => Term.Font.Yellow
  | Blue    => Term.Font.Blue
  | Magenta => Term.Font.Magenta
  | Cyan    => Term.Font.Cyan
  | White   => Term.Font.White
  end

pub data Style =
  | Clear
  | Style of { ?fg : Color
             , ?bg : Color
             , ?underline : Bool
             , ?strike : Bool
             }

pub data CurrStyle = { fg        : Option Color
                     , bg        : Option Color
                     , underline : Bool
                     , strike    : Bool
                     }

let emptyCurrStyle = CurrStyle
  { fg = None
  , bg = None
  , underline = False
  , strike    = False
  }

method addStyle (c : CurrStyle) (s : Style) =
  match (c, s) with
  | _, Clear => emptyCurrStyle
  | c, Style {fg, bg, underline, strike} =>
    let fg =
      match fg with
      | None => c.fg
      | Some c => Some c
      end
    let bg =
      match bg with
      | None => c.fg
      | Some c => Some c
      end
    let strike = strike.unwrapOr c.strike
    let underline = underline.unwrapOr c.underline
    in
    CurrStyle {fg, bg, strike, underline}
  end

method getDeltaCode (old : CurrStyle) (new : CurrStyle) =
  let fg =
    if not (old.fg == new.fg) then 
      match new.fg with
      | Some c => Term.Font.setFgColor c.toAnsi
      | None => Term.Font.setDflFgColor
      end
    else ""
  let bg =
    if not (old.bg == new.bg) then
      match new.bg with
      | Some c => Term.Font.setBgColor c.toAnsi
      | None => Term.Font.setDflBgColor
      end
    else ""
  let underline =
    if old.underline != new.underline then
      if new.underline then Term.Font.setUnderline
      else Term.Font.resetUnderline
    else ""
  let strike =
    if old.strike != new.strike then
      if new.strike then Term.Font.setStrikeout
      else Term.Font.resetStrikeout
    else ""
  in
  strListCat [fg, bg, underline, strike]

# produces next ansi string to continue style
pub data Stylist E =
  { pushStyle : Style ->[E] String
  , popStyle  : Unit  ->[E] String
  }

pub let styleH =
  handler
    Stylist
      { pushStyle = effect s / r => fn st =>
        match (st : List CurrStyle) with
        | [] => impossible ()
        | old :: styles =>
          let new = old.addStyle s in
          r (old.getDeltaCode new) (new :: st)
        end
      , popStyle  = effect s / r => fn st =>
        match st with
        | old :: new :: styles => r (old.getDeltaCode new) (new :: styles)
        | _ => impossible ()
        end
      }
    return x => fn _ => x
    finally c => c [emptyCurrStyle]
  end
