{# This file is part of DBL, released under the MIT license.
 # See LICENSE for details.
 #}

import open /Lazy

## # Stream module

{##
  This module provides lazy lists, also known as streams.
  Each and every node of a stream is deffered, meaniung that
  no computation occurs unless results are forcibly read.

  Contrary to regular lists, streams may be infinite. Some iterative
  functions may never terminate!
 ##}

rec
  ## Stream type.
  abstr data Stream X = Stream of Lazy (Node X)
  data Node X =
    | Cons of X, Stream X
    | Nil
end

parameter X : type

method unstream (Stream xs) = xs

{## Creates stream from given list. ##}
pub let rec fromList (xs : List X) =
  Stream (lazy (fn _ =>
    match xs with
    | x :: xs => Cons x (fromList xs)
    | []      => Nil
    end)) : Stream X

{## Returns all elements of a stream as a list. ##}
pub let rec toList (Stream xs : Stream X) =
  match xs.force with
  | Cons x xs => x :: toList xs
  | Nil       => [] : List X
  end : List X

{##
  Initializes lazy stream by iteratively applying function `f` on previous results.

  This function may generate infinite stream.
 ##}
pub let rec unfold {S} (seed : S) (f : S ->[] Option (Pair X S)) =
  Stream (lazy (fn _ =>
    match f seed with
    | None             => Nil
    | Some (val, seed) => Cons val (unfold seed f)
    end)) : Stream X

{## Creates an empty stream. ##}
pub let empty {X} = (Stream (pureLazy Nil) : Stream X)

{## Checks if a stream is empty. ##}
pub let isEmpty {X} (Stream xs : Stream X) =
  match xs.force with
  | Nil => True
  | _   => False
  end

{## Creates a stream from given element. ##}
pub let singleton (elem : X) =
  Stream (pureLazy (Cons elem empty))

{## Adds an element to the head of a stream. ##}
pub let cons (elem : X) (tail : Stream X) =
  Stream (pureLazy (Cons elem tail))

{## Adds a deffered element to the head of a stream. ##}
pub let lazyCons (elem : Lazy X) (tail : Stream X) =
  Stream (lazy (fn _ => Cons elem.force tail))

{##
  Returns head and tail of a stream.
  Returns `None` if stream is empty.
 ##}
pub let uncons (Stream xs : Stream X) =
  match xs.force with
  | Nil       => None
  | Cons x xs => Some (x, xs)
  end

{##
  Creates a new stream with mapped values.
 ##}
pub let rec map {Y} (f : X ->> Y) (Stream xs : Stream X) =
  Stream (lazy (fn _ =>
    match xs.force with
    | Cons x xs => Cons (f x) (map f xs)
    | Nil       => Nil
    end)) : Stream Y

{## Appends two streams together. ##}
pub let rec append (Stream xs : Stream X) (ys : Stream X) =
  Stream (lazy (fn _ =>
    match xs.force with
    | Cons x xs => Cons x (append xs ys)
    | Nil       => ys.unstream.force
    end)) : Stream X

{## Performs monadic bind over a stream. ##}
pub let rec concatMap {Y} (f : X ->> Stream Y) (Stream xs : Stream X) =
  Stream (lazy (fn _ =>
    match xs.force with
    | Cons x xs => append (f x) (concatMap f xs) >.unstream >.force
    | Nil       => Nil
    end)) : Stream Y

{##
  Returns a longest prefix of a stream that satisfies given predicate
 ##}
pub let rec takeWhile (f : X ->> Bool) (Stream xs : Stream X) =
  Stream (lazy (fn _ =>
    match xs.force with
    | Cons x xs =>
      if f x then
        Cons x (takeWhile f xs)
      else
        Nil
    | Nil => Nil
    end)) : Stream X

{## Returns a substream with values that satisfies given predicate. ##}
pub let rec filter (f : X ->> Bool) (Stream xs : Stream X) =
  Stream (lazy (fn _ =>
    match xs.force with
    | Nil       => Nil
    | Cons x xs =>
      if f x then
        Cons x (filter f xs)
      else
        filter f xs >.unstream >.force
    end)) : Stream X

{##
  Folds stream to a single value, beginning with right-most value.
 ##}
pub let rec foldRight {A}
  (f : X -> A ->> A) (Stream xs : Stream X) (acc : A) =
    match xs.force with
    | Cons x xs => f x (foldRight f xs acc)
    | Nil       => acc
    end : A

{##
  Folds stream to a single value from right to left. Takes the last
  element of as stream  as an initial accumulator.
  Calls `~onError` in case of an empty stream.

  @param ~onError Fallback for an empty stream.
 ##}
pub let foldRight1Err {~onError : Unit ->> X}
  (f : X -> X ->> X) (Stream xs : Stream X) =
    let rec foldRight1ErrAux y (Stream xs) =
      match xs.force with
      | Nil       => y
      | Cons x xs =>
          f y (foldRight1ErrAux x xs)
      end in
    match xs.force with
    | Nil       => ~onError ()
    | Cons x xs => foldRight1ErrAux x xs
    end : X
    
{## Checks if all elements of given streams are equal pairwise. ##}
pub let equal
  {method equal : X -> X ->[] Bool}
  (xs : Stream X)
  (ys : Stream X) =
    let rec equalAux ((Stream xs) : Stream X) ((Stream ys) : Stream X) =
      match (xs.force, ys.force) with
      | Nil, Nil => True
      | Cons x xs, Cons y ys =>
        if x == y then
          equalAux (xs : Stream X) ys
        else
          False
      | _ => False
    end in
    equalAux xs ys

{## Enables stream showing in REPL. ##}
pub let show (_ : Stream X) = "#Stream"

parameter ~onError

pub method toList = toList
pub method uncons = uncons
pub method map = flip map
pub method add = append
pub method concatMap = flip concatMap
pub method filter = flip filter
pub method foldRight xs f acc = foldRight f xs acc
pub method foldRight1Err = flip foldRight1Err
pub method equal = equal
pub method show = show
