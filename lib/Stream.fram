import open /Lazy

rec
  abstr data Stream X = Stream of Lazy (Node X)
  data Node X =
    | Cons of X, Stream X
    | Nil
end

method unstream (Stream xs) = xs

pub let rec fromList xs = Stream (lazy (fn _ =>
  match xs with
  | x :: xs => Cons x (fromList xs)
  | [] => Nil
  end))

pub let empty = Stream (pureLazy (fn _ => Nil))

pub let isEmpty (Stream xs) = match xs.force with
  | Nil => True
  | _ => False
  end

pub let singleton elem = Stream (pureLazy (fn _ => Cons elem empty))

pub let lazyStream
  {X : type}
  (xs : Unit ->[] Stream X) = 
    Stream (lazy (fn _ => xs () >.unstream >.force))

pub let cons
  {X : type} 
  (elem : X)
  (tail : Stream X) =
    Stream (lazy (fn () => Cons elem tail))

pub let lazyCons
  {X : type}
  (elem : X)
  (tail : Unit ->[] Stream X) =
    Stream (lazy (fn () => Cons elem (lazyStream tail)))

pub let uncons (Stream xs) =
  match xs.force with
  | Nil => None
  | Cons x xs => Some (x, xs)
  end

pub method uncons = uncons

pub let rec map f (Stream xs) = Stream (lazy (fn _ =>
  match xs.force with
  | Cons x xs => Cons (f x) (map f xs)
  | Nil => Nil
  end))

pub method map xs f = map f xs

pub let rec append (Stream xs) (ys : Stream _) = Stream (lazy (fn _ =>
  match xs.force with
  | Cons x xs => Cons x (append xs ys)
  | Nil => ys.unstream.force
  end))

pub method add = append

pub let rec bind f (Stream xs) = Stream (lazy (fn _ =>
  match xs.force with
  | Cons x xs => append (f x) (bind f xs) >.unstream >.force
  | Nil => Nil
  end))

pub let rec takeWhile f (Stream xs) = Stream (lazy (fn _ =>
  match xs.force with
  | Cons x xs =>
    if f x then
      Cons x (takeWhile f xs)
    else
      Nil
  | Nil => Nil
  end))

pub let rec filter f (Stream xs) = Stream (lazy (fn _ =>
  match xs.force with
  | Nil => Nil
  | Cons x xs =>
    if f x then
      Cons x (filter f xs)
    else
      filter f xs >.unstream >.force
  end))

pub let rec foldr1 f (Stream xs) =
  match xs.force with
  | Nil => impossible ()
  | Cons x xs =>
    if isEmpty xs then
      x
    else
      f x (foldr1 f xs)
  end
    
pub method rec equal
  { X : type
  , method equal : X -> X ->> Bool }
  ((Stream xs) : Stream X)
  ((Stream ys) : Stream X) =
    match (xs.force, ys.force) with
    | Nil, Nil => True
    | Cons x xs, Cons y ys =>
      if x == y then
        (xs : Stream X).equal ys
      else
        False
    | _ => False
    end

