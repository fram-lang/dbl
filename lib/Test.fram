{# This file is part of DBL, released under MIT license.
   See LICENSE for details.
 #}


import open AnsiTerminal
import Mutable

{# ========================================================================= #}
{# Testing data types #}

## Information about assertion fail in test
data AssertInfo =
  { msg : String
  , line : Int
  , file : String
  }

{# TODO : Add tags to tests and suites #}

## Test case to be run at a later time.
data TestCase =
  { name : String
  , line : Int
  , file : String
  , testBody : Unit ->[IO] List AssertInfo {# Maybe this doesn't go here #}
  }

{##
  Internal representation of test suite.
  Holds tests.
##}
data TestSuiteInternal =
  { name : String
  , line : Int
  , file : String
  , tests : List TestCase
  }

data TestSuite =
 | TestSuite of { name : String}

{# ========================================================================= #}
{# Printing functions #}

# TODO delete when improved format methods are introduced
let strFmt = () #StringFmt {escape=False}
method format {?fmt : Unit} (self : String) = self

let warn (msg : String) =
  printStrLn "\{Color.setFgColor Color.Yellow | strFmt
    }[WARNING] \{ msg | strFmt }\{ Color.resetAll | strFmt }"

let printGlobalPreamble () =
  printStrLn "[====] Running global tests"

method printPreamble (TestSuiteInternal {file, line, name}) =
  printStrLn "[====] Running test suite \{name}";
  printStrLn "[    ] from \{file | strFmt}:\{line}"

method printCaseOk (TestCase {name}) =
  {# TODO : add printing of line and file of the test (maybe?) #}
  printStrLn "[ \{
    Color.setFgColor Color.Green | strFmt
  }OK\{Color.resetAll | strFmt} ] \{name | strFmt}"

method printCaseFail (AssertInfo {msg, file, line}) =

let rec printTestResultAux (assertInfos : List AssertInfo) =
  match assertInfos with
  | [] => ()
  | AssertInfo { file, line, msg } :: assertInfos =>
    printStrLn "       In \{ file | strFmt }:\{ line } assertion failed:";
    printStrLn "       \{ msg | strFmt}"
    aux assertInfos
  end

method printTestResult (TestCase { name, line, file }) assertInfos =
  match assertInfos with
  | [] =>
    printStrLn "[ \{
      Color.setFgColor Color.Green | strFmt
    }OK\{Color.resetAll | strFmt} ] \{ name | strFmt} from \{
      file | strFmt }:\{ line | strFmt }";
      True
  | _  =>
    printStr   "[\{ Color.setFgColor Color.Red | strFmt }FAIL";
    printStr   "\{ Color.resetAll | strFmt }]";
    printStrLn "\{ tc.name | strFmt } from \{ tc.file | strFmt }:\{ tc.line }";
    printTestResultAux assertInfos;
    False
  end

let printSuiteFooter (succ : Int) (fail : Int) =
  if succ == 0 && fail == 0 then
    printStrLn "[====] No tests have been run!"
  else if succ == 1 && fail == 0 then
    printStrLn "[====] Test have passed!"
  else if succ == 2 && fail == 0 then
    printStrLn "[====] Both tests passed!"
  else if fail == 0 then
    printStrLn "[====] All \{succ} tests have passed!"
  else
    printStrLn "[====] \{succ}/\{fail + succ} tests have passed!";
  printStrLn ""

{# ========================================================================= #}
{# Running Test Logic #}

{##
  Test case effector object.
  Provides two functionalities:
  - allows for reporting assertion failure, which ends test immediately
  - allows for reporting expectation failure, which allows for the test
    to continue, but at the end test fails anyway.
##}
data TestArbiter E =
  { abort : {X} -> AssertInfo ->[E] X
  , fail  : AssertInfo ->[E] Unit
  }

{# TODO : Rewrite to use tail-recurrsion #}
let testArbiterHandler =
  handler TestArbiter
    { abort = effect assertInfo => [ assertInfo ]
    , fail  = effect assertInfo => assertInfo :: resume ()
    }
    return _ => []
  end

method runTest (tc : TestCase) =
  let errors = tc.testBody () in
  tc.printTestResult errors;
  errors

{# This module is to be used in other parts of standard library,
    so some functionality is explicitely reimplemented #}
let rec runSuiteAux (succ, fail) (tests : List TestCase) =
  match tests with
  | [] => (succ, fail)
  | tc :: tests =>
    if tc.runTest
    then runSuiteAux (1+succ, fail) tests
    else runSuiteAux (succ, 1+fail) tests
  end

method runSuite (suite : TestSuiteInternal) =
  match globalTests.get with
  | [] => suite.reportEmptySuite
  | globalTests =>
    suite.printPreamble();
    let (succ, fail) = runSuiteAux (0, 0) globalTests in
    printSuiteFooter succ fail;
    (succ, fail)
  end

{# ========================================================================= #}
{# MainTestRunner #}

data MainTestRunner =
  { testSuites  : Mutable.Ref IO (List TestSuiteInternal)
  , globalTests : Mutable.Ref IO (List TestCase)
  }

let mainTestRunner = MainTestRunner
  { testSuites  = Mutable.ioMut.ref []
  , globalTests = Mutable.ioMut.ref []
  }

let rec runAllSuites testFailed (suites : List TestSuiteInternal) =
  match suites with
  | [] => ()
  | suite :: suites =>
    let (_, fail) = suite.runSuite in
    runAllSuites (testFailed || fail > 0) suites
  end

method runAllTests (MainTestRunner { globalTests, testSuites }) =
  let testFailed =
    match globalTests.get with
    | [] => ()
    | globalTests =>
      printGlobalPreamble();
      let (succ, fail) = runSuiteAux (0, 0) globalTests in
      printSuiteFooter succ fail;
      fail > 0
    end
  let testFailed = runAllSuites testFailed testSuites.get in
  if testFailed
  then runtimeError "[====] Test Environment Failed"
  else ()

{##
  If this file is imported, all registered tests will be run after program
  finishes
##}
handle _ = ()
  return _ =>
    {# TODO : Implement some sort of argument parsing,
              and tests-to-run selection #}
    {# TODO : When attributes are implemented, add them here #}
    let _ = mainTestRunner.runAllTests in ()
  finally _ => ()

method addGlobalTest (MainTestRunner { globalTests }) tc =
  globalTests := tc :: globalTests.get

method addTest (TestSuiteInternal { name, line, file, tests }) tc =
  TestSuiteInternal { name, line, file, tests=tc :: tests }

let rec updateList (suites : List TestSuiteInternal) suiteName tc =
  match suites with
  | [] => warn "TestRunner: Internal library error"; []
  | suite :: suites =>
    if suite.name == suiteName
    then suite.addTest tc :: suites
    else suite :: updateList suites suiteName tc
  end

method addTestToSuite (MainTestRunner { testSuites }) (TestSuite { name }) tc =
  testSuites := updateList testSuites.get name tc

method addSuite (MainTestRunner { testSuites }) suite =
  testSuites := suite :: testSuites.get

{# ========================================================================= #}
{# Registering tests #}

{## This function wraps test body, handling test arbiter effect ##}
let constructTest name line file
    (f : {E, ~testArbiter : TestArbiter E} ->
      Unit ->[E, IO] Unit) =
  let testBody () =
    handle ~testArbiter / F with testArbiterHandler
    let ~onError () = ~testArbiter.abort
      (AssertInfo {msg="Uncaught ~onError call", line, file })
    in
    {# TODO : Add measuring execution time #}
    f ()
  in TestCase {name, line, file, testBody}


pub let registerGlobalTest
    {~__line__ = line, ~__file__ = file} name
    (f : {E, ~testArbiter : TestArbiter E} ->
      Unit ->[E, IO] Unit) =
  mainTestRunner.addGlobalTest (constructTest name line file f)

pub method registerTest
    {~__line__ = line, ~__file__ = file}
    (suite : TestSuite) testName
    (f : {E, ~testArbiter : TestArbiter E} ->
      Unit ->[E, IO] Unit) =
  mainTestRunner.addTestToSuite suite (constructTest testName line file f)

pub let createTestSuite {~__line__ = line, ~__file__ = file} name =
  mainTestRunner.addSuite (TestSuiteInternal { name, file, line, tests=[] });
  TestSuite { name }

{# ========================================================================= #}
{# Assertion and Expectation Interface #}

{##
  Asserts that given value is True.
 ##}
pub let assertTrue
    {~__line__, ~__file__, ~testArbiter : TestArbiter _, ?msg : String}
    cond =
  if cond then
    ()
  else
    ~testArbiter.abort
      (AssertInfo {line= ~__line__, file= ~__file__, msg =
        msg.unwrapOr "Assertion Failed: Expected to be true"})

{##
  Asserts that given value if False
 ##}
pub let assertFalse
    {~__line__, ~__file__, ~testArbiter : TestArbiter _, ?msg : String}
    cond =
  assertTrue
    { msg=msg.unwrapOr "Assertion Failed: Expected to be false" } (not cond)

{##
  Asserts that 2 values are equal, according to first value's `equal` method.
 ##}
pub let assertEq 
    { ~__line__
    , ~__file__
    , ~testArbiter : TestArbiter _
    , ?msg : String
    , X : type
    , Y : type
    , method equal : X ->> Y ->> Bool } 
    (expected : X) (actual : Y) =
  assertTrue
    { msg = "Assertion Failed: Expected values to be equal" }
    (expected.equal actual)

{##
  Asserts that 2 values are equal, according to first value's `equal` method.
  Default error message is generated using format methods.
 ##}
pub let assertEqF
    { ~__line__
    , ~__file__
    , ~testArbiter : TestArbiter _
    , ?msg : String
    , X : type
    , Y : type
    , method format : X ->> String
    , method format : Y ->> String
    , method equal : X ->> Y ->> Bool } 
    (expected : X) (actual : Y) =
  assertTrue
    {msg =
      "Assertion Failed: Expected\n\t\{expected}\n\t\{actual}\nto be equal"}
    (expected.equal actual)

let callsOnError (f : {E, ~onError : _ ->[E] _} -> Unit ->[E] _) =
  handle
    ~onError = effect _ => True
    return _ => False
  in f ()

{##
  Asserts that given function will call ~onError method.
 ##}
pub let assertCallsOnError
    { ~__line__
    , ~__file__
    , ~testArbiter
    , ?msg : String }
    (f : {E, ~onError : _ ->[E] _} -> Unit ->[E] _ ) =
  assertTrue
    {msg = "Assertion Failed: Expected function to call on error implicit"}
    (callsOnError f)

{##
  Asserts that given function will not call ~onError method.
 ##}
pub let assertDoesNotCallOnError
    { ~__line__
    , ~__file__
    , ~testArbiter
    , ?msg : String }
    (f : {E, ~onError : _ ->[E] _} -> Unit ->[E] _ ) =
  assertFalse
    {msg = "Assertion Failed: Expected function to not call on error implicit"}
    (callsOnError f)


{##
  Expects that given value is True.
 ##}
pub let expectTrue
    {~__line__, ~__file__, ~testArbiter : TestArbiter _, ?msg : String}
    cond =
  if cond then
    ()
  else
    ~testArbiter.fail
      (AssertInfo {line= ~__line__, file= ~__file__,
        msg = msg.unwrapOr "Expectation Failed: Expected to be true"})

{##
  Expects that given value if False
 ##}
pub let expectFalse
    {~__line__, ~__file__, ~testArbiter : TestArbiter _, ?msg : String}
    cond =
  expectTrue
    { msg=msg.unwrapOr "Expectation Failed: Expected to be false"}
    (not cond)

{##
  Expects that 2 values are equal, according to first value's `equal` method.
 ##}
pub let expectEq 
    { ~__line__
    , ~__file__
    , ~testArbiter : TestArbiter _
    , ?msg : String
    , X : type
    , Y : type
    , method equal : X ->> Y ->> Bool } 
    (expected : X) (actual : Y) =
  expectTrue
    { msg = "Expectation Failed: Expected values to be equal"}
    (expected.equal actual)

{##
  Expects that 2 values are equal, according to first value's `equal` method.
  Default error message is generated using format methods.
 ##}
pub let expectEqF
    { ~__line__
    , ~__file__
    , ~testArbiter : TestArbiter _
    , ?msg : String
    , X : type
    , Y : type
    , method format : X ->> String
    , method format : Y ->> String
    , method equal : X ->> Y ->> Bool } 
    (expected : X) (actual : Y) =
  expectTrue
    {msg =
      "Expectation Failed: Expected\n\t\{expected}\n\t\{actual}\nto be equal"}
    (expected.equal actual)

let callsOnError (f : {E, ~onError : _ ->[E] _} -> Unit ->[E] _) =
  handle
    ~onError = effect _ => True
    return _ => False
  in f ()

{##
  Expects that given function will call ~onError method.
 ##}
pub let expectCallsOnError
    { ~__line__
    , ~__file__
    , ~testArbiter
    , ?msg : String }
    (f : {E, ~onError : _ ->[E] _} -> Unit ->[E] _ ) =
  expectTrue
    {msg = "Expectation Failed: Expected function to call on error implicit"}
    (callsOnError f)

{##
  Expects that given function will not call ~onError method.
 ##}
pub let expectDoesNotCallOnError
    { ~__line__
    , ~__file__
    , ~testArbiter
    , ?msg : String }
    (f : {E, ~onError : _ ->[E] _} -> Unit ->[E] _ ) =
  expectFalse
    {msg =
      "Expectation Failed: Expected function to not call on error implicit"}
    (callsOnError f)

let suite = createTestSuite "Prelude/*"

let _ = suite.registerTest "`chr` calls on error" (fn () =>
  assertCallsOnError (fn _ => chr 300))

let _ = suite.registerTest "`chr` does not call on error" (fn () =>
  assertDoesNotCallOnError (fn _ => chr 127))

let mkStr _ _ = ""

let _ = suite.registerTest "`mkStr` count = 0" (fn _ =>
  assertEq (mkStr "abc" 0) "")

let _ = suite.registerTest "`mkStr` count < 0" (fn _ =>
    assertEq (mkStr "abc" (-1)) "";
    assertEq (mkStr "abc" (-10)) "")
  
let _ = suite.registerTest "`mkStr` count > 0" (fn _ =>
    assertEq (mkStr "abc" 1) "abc";
    assertEq (mkStr "abc" 2) "abcabc";
    assertEq (mkStr "abc" 3) "abcabcabc";
    assertEq (mkStr "abc" 5) "abcabcabcabcabc")

