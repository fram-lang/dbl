{# This file is part of DBL, released under MIT license.
   See LICENSE for details.
 #}


import open AnsiTerminal
import open Mutable

{# ========================================================================= #}
{# Testing data types #}

data ErrorType = | Assertion | Expectation

## Information about assertion fail in test
data ErrorInfo =
  { msg : String
  , line : Int
  , file : String
  , errorType : ErrorType
  }

{# TODO : Add tags to tests and suites #}

data TestCase =
  { name : String
  , line : Int
  , file : String
  , body : Unit ->[IO] List ErrorInfo
  }

data rec TestSuiteInternal =
  { name   : String
  , line   : Int
  , file   : String
  , suites : Ref IO (List TestSuiteInternal)
  , tests  : Ref IO (List TestCase)
  }

abstr data TestSuite =
  { suites : Ref IO (List TestSuiteInternal)
  , tests  : Ref IO (List TestCase)
  }

{# ========================================================================= #}
{# Helper functions #}

{# This module is to be used in other parts of standard library,
    so some functionality is reimplemented #}
let listRev xs =
  let rec aux acc xs =
    match xs with
    | [] => acc
    | x :: xs => aux (x :: acc) xs
    end
  in aux [] xs

let rec listFold f acc xs =
  match xs with
  | [] => acc
  | x :: xs => listFold f (f acc x)  xs
  end

let rec listIter f xs =
  match xs with
  | [] => ()
  | x :: xs => f x; listIter f xs
  end

{# ========================================================================= #}
{# Printing functions #}

# TODO delete when improved format methods are introduced
let strFmt = () #StringFmt {escape=False}
method format {?fmt : Unit} (self : String) = self

let warn (msg : String) =
  printStrLn "\{Color.setFgColor Color.Yellow | strFmt
    }[WARNING] \{ msg | strFmt }\{ Color.resetAll | strFmt }"

method format (et : ErrorType) =
  match et with
  | Assertion   => "assertion"
  | Expectation => "expectation"
  end

let printErrorInfo (ErrorInfo { msg, line, file, errorType }) =
  printStrLn "  <>  In \{ file | strFmt }:\{ line } \{ errorType } failed:";
  printStrLn "       \{ msg | strFmt}"

let printGlobalPreamble () =
printStrLn "[====] Running global tests"

method printPreamble (TestSuiteInternal {file, line, name}) =
  printStrLn "[====] Running test suite \{name}";
  printStrLn "[    ] from \{file | strFmt}:\{line}"

method printTestSuccess (TestCase { name, line, file }) =
  printStr   "[ \{ Color.setFgColor Color.Green | strFmt }OK";
  printStr   "\{Color.resetAll | strFmt} ]";
  printStrLn " \{ name | strFmt} from \{ file | strFmt }:\{ line | strFmt }"

method printTestFailure (TestCase { name, line, file }) assertInfos =
  printStr   "[\{ Color.setFgColor Color.Red | strFmt }FAIL";
  printStr   "\{ Color.resetAll | strFmt }]";
  printStrLn " \{ name | strFmt } from \{ file | strFmt }:\{ line }";
  listIter printErrorInfo (listRev assertInfos)

method reportEmptySuite (TestSuiteInternal { name }) =
  printStrLn "[====] Test Suite \{name} has no tests"

let printSuiteFooter (succ : Int) (fail : Int) =
  if succ == 0 && fail == 0 then
    printStrLn "[====] No tests have been run!"
  else if succ == 1 && fail == 0 then
    printStrLn "[====] Test have passed!"
  else if succ == 2 && fail == 0 then
    printStrLn "[====] Both tests passed!"
  else if fail == 0 then
    printStrLn "[====] All \{succ} tests have passed!"
  else
    printStrLn "[====] \{succ}/\{fail + succ} tests have passed!";
  printStrLn ""

{# ========================================================================= #}
{# Running Test Logic #}

{##
  Test case effector object.
  Provides two functionalities:
  - allows for reporting assertion failure, which ends test immediately
  - allows for reporting expectation failure, which allows for the test
    to continue, but at the end test fails anyway.
##}
data TestArbiter E =
  { abort : {X} -> ErrorInfo ->[E] X
  , fail  : ErrorInfo ->[E] Unit
  }

{# TODO : Rewrite to use tail-recurrsion #}
let testArbiterHandler =
  handler TestArbiter
    { abort = effect assertInfo => [ assertInfo ]
    , fail  = effect assertInfo => assertInfo :: resume ()
    }
    return _ => []
  end

{##
  Runs the test
  Returns True if the test passed, False otherwise
##}
method runTest (tc : TestCase) =
  match tc.body() with
  | []     => 
    tc.printTestSuccess;
    True
  | errors =>
    tc.printTestFailure errors;
    False
  end

let evalTest (succ, fail) (tc : TestCase) =
  if tc.runTest then (1+succ, fail) else (succ, 1+fail)

rec
  {##
    Runs Tests associated with suite,
    then runs sub-suite
    Returns True if all tests and sub-suite passed, False otherwise
  ##}
  method runSuite (suite : TestSuiteInternal) =
    let allSucceeded =
      match suite.tests.get with
      | [] => suite.reportEmptySuite; True
      | tests =>
        suite.printPreamble;
        let (succ, fail) = listFold evalTest (0, 0) (listRev tests) in
        printSuiteFooter succ fail;
        fail == 0
      end
    in listFold evalSuite allSucceeded (listRev suite.suites.get)

  let evalSuite acc (suite : TestSuiteInternal) = suite.runSuite && acc
end

{# ========================================================================= #}
{# MainTestRunner #}

data MainTestRunner =
  { suites : Ref IO (List TestSuiteInternal)
  , tests  : Ref IO (List TestCase)
  }

let mainTestRunner = MainTestRunner
  { suites = ioMut.ref []
  , tests  = ioMut.ref []
  }

method runAllTests (MainTestRunner{ suites, tests }) =
  let allSucceeded =
    match tests.get with
    | [] => True
    | tests =>
      printGlobalPreamble ();
      let (succ, fail) = listFold evalTest (0, 0) (listRev tests) in
      printSuiteFooter succ fail;
      fail > 0
    end
  let allSucceeded = listFold evalSuite allSucceeded (listRev suites.get) in
  if allSucceeded then ()
  {# TODO : Change this to normal print + exit #}
  else runtimeError "[====] Test Environment Failed"

{##
  If this file is imported, all registered tests will be run after program
  finishes
##}
handle _ = ()
  return _ =>
    {# TODO : Implement some sort of argument parsing,
              and tests-to-run selection #}
    {# TODO : When attributes are implemented, add them here #}
    let _ = mainTestRunner.runAllTests in ()
  finally _ => ()

method addTest (MainTestRunner { tests }) tc =
  tests := tc :: tests.get

method addTest (TestSuite { tests }) tc =
  tests := tc :: tests.get

method addSuite (MainTestRunner { suites }) suite =
  suites := suite :: suites.get

method addSuite (TestSuite { suites }) suite =
  suites := suite :: suites.get

{# ========================================================================= #}
{# Registering tests #}

{## This function wraps test body, handling test arbiter effect ##}
let constructTest name line file
    (f : {E, ~testArbiter : TestArbiter E} ->
      Unit ->[E, IO] Unit) =
  let body () =
    handle ~testArbiter / F with testArbiterHandler
    let ~onError () = ~testArbiter.abort (ErrorInfo
      { msg="Uncaught ~onError call", line, file, errorType=Assertion })
    in
    {# TODO : Add measuring execution time #}
    f ()
  in TestCase {name, line, file, body }


pub let addGlobalTest
    {~__line__ = line, ~__file__ = file} name
    (f : {E, ~testArbiter : TestArbiter E} ->
      Unit ->[E, IO] Unit) =
  mainTestRunner.addTest (constructTest name line file f)

pub method addTest
    {~__line__ = line, ~__file__ = file}
    (suite : TestSuite) testName
    (f : {E, ~testArbiter : TestArbiter E} ->
      Unit ->[E, IO] Unit) =
  suite.addTest (constructTest testName line file f)

pub let createTestSuite {~__line__ = line, ~__file__ = file} name =
  let suites = ioMut.ref []
  let tests = ioMut.ref []
  let suite = TestSuiteInternal { name, file, line, tests, suites } in
  mainTestRunner.addSuite suite;
  TestSuite { suites, tests }

pub method addSuite
    {~__line__ = line, ~__file__ = file}
    (suite : TestSuite) name =
  let suites = ioMut.ref []
  let tests = ioMut.ref [] in
  let suite' = TestSuiteInternal { name, file, line, tests, suites } in
  suite.addSuite suite';
  TestSuite { suites, tests }

{# ========================================================================= #}
{# Assertion and Expectation Interface #}

{##
  Asserts that given value is True.
 ##}
pub let assertTrue
    {~__line__, ~__file__, ~testArbiter : TestArbiter _, ?msg : String}
    cond =
  if cond then
    ()
  else
    ~testArbiter.abort
      (ErrorInfo {line= ~__line__, file= ~__file__, errorType=Assertion
        , msg = msg.unwrapOr "Assertion Failed: Expected to be true"})

{##
  Asserts that given value if False
 ##}
pub let assertFalse
    {~__line__, ~__file__, ~testArbiter : TestArbiter _, ?msg : String}
    cond =
  assertTrue
    { msg=msg.unwrapOr "Assertion Failed: Expected to be false" } (not cond)

{##
  Asserts that 2 values are equal, according to first value's `equal` method.
 ##}
pub let assertEq 
    { ~__line__
    , ~__file__
    , ~testArbiter : TestArbiter _
    , ?msg : String
    , X : type
    , Y : type
    , method equal : X ->> Y ->> Bool } 
    (expected : X) (actual : Y) =
  assertTrue
    { msg = "Assertion Failed: Expected values to be equal" }
    (expected.equal actual)

{##
  Asserts that 2 values are equal, according to first value's `equal` method.
  Default error message is generated using format methods.
 ##}
pub let assertEqF
    { ~__line__
    , ~__file__
    , ~testArbiter : TestArbiter _
    , ?msg : String
    , X : type
    , Y : type
    , method format : X ->> String
    , method format : Y ->> String
    , method equal : X ->> Y ->> Bool } 
    (expected : X) (actual : Y) =
  assertTrue
    {msg =
      "Assertion Failed: Expected\n\t\{expected}\n\t\{actual}\nto be equal"}
    (expected.equal actual)

let callsOnError (f : {E, ~onError : _ ->[E] _} -> Unit ->[E] _) =
  handle
    ~onError = effect _ => True
    return _ => False
  in f ()

{##
  Asserts that given function will call ~onError method.
 ##}
pub let assertCallsOnError
    { ~__line__
    , ~__file__
    , ~testArbiter
    , ?msg : String }
    (f : {E, ~onError : _ ->[E] _} -> Unit ->[E] _ ) =
  assertTrue
    {msg = "Assertion Failed: Expected function to call on error implicit"}
    (callsOnError f)

{##
  Asserts that given function will not call ~onError method.
 ##}
pub let assertDoesNotCallOnError
    { ~__line__
    , ~__file__
    , ~testArbiter
    , ?msg : String }
    (f : {E, ~onError : _ ->[E] _} -> Unit ->[E] _ ) =
  assertFalse
    {msg = "Assertion Failed: Expected function to not call on error implicit"}
    (callsOnError f)


{##
  Expects that given value is True.
 ##}
pub let expectTrue
    {~__line__, ~__file__, ~testArbiter : TestArbiter _, ?msg : String}
    cond =
  if cond then
    ()
  else
    ~testArbiter.fail
      (ErrorInfo {line= ~__line__, file= ~__file__, errorType=Expectation
        , msg=msg.unwrapOr "Expectation Failed: Expected to be true"})

{##
  Expects that given value if False
 ##}
pub let expectFalse
    {~__line__, ~__file__, ~testArbiter : TestArbiter _, ?msg : String}
    cond =
  expectTrue
    { msg=msg.unwrapOr "Expectation Failed: Expected to be false"}
    (not cond)

{##
  Expects that 2 values are equal, according to first value's `equal` method.
 ##}
pub let expectEq 
    { ~__line__
    , ~__file__
    , ~testArbiter : TestArbiter _
    , ?msg : String
    , X : type
    , Y : type
    , method equal : X ->> Y ->> Bool } 
    (expected : X) (actual : Y) =
  expectTrue
    { msg = "Expectation Failed: Expected values to be equal"}
    (expected.equal actual)

{##
  Expects that 2 values are equal, according to first value's `equal` method.
  Default error message is generated using format methods.
 ##}
pub let expectEqF
    { ~__line__
    , ~__file__
    , ~testArbiter : TestArbiter _
    , ?msg : String
    , X : type
    , Y : type
    , method format : X ->> String
    , method format : Y ->> String
    , method equal : X ->> Y ->> Bool } 
    (expected : X) (actual : Y) =
  expectTrue
    {msg =
      "Expectation Failed: Expected\n\t\{expected}\n\t\{actual}\nto be equal"}
    (expected.equal actual)

let callsOnError (f : {E, ~onError : _ ->[E] _} -> Unit ->[E] _) =
  handle
    ~onError = effect _ => True
    return _ => False
  in f ()

{##
  Expects that given function will call ~onError method.
 ##}
pub let expectCallsOnError
    { ~__line__
    , ~__file__
    , ~testArbiter
    , ?msg : String }
    (f : {E, ~onError : _ ->[E] _} -> Unit ->[E] _ ) =
  expectTrue
    {msg = "Expectation Failed: Expected function to call on error implicit"}
    (callsOnError f)

{##
  Expects that given function will not call ~onError method.
 ##}
pub let expectDoesNotCallOnError
    { ~__line__
    , ~__file__
    , ~testArbiter
    , ?msg : String }
    (f : {E, ~onError : _ ->[E] _} -> Unit ->[E] _ ) =
  expectFalse
    {msg =
      "Expectation Failed: Expected function to not call on error implicit"}
    (callsOnError f)
