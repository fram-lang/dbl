import open AnsiTerminal

# TODO delete when improved format methods are introduced
let strFmt = () #StringFmt {escape=False}
method format {?fmt : Unit} (self : String) = self

## Carries inforamtion about failed test assertion
data AssertInfo =
  { msg  : String
  , line : Int
  }

## Carries information about failed test case
data TestCase = 
  { name : String
  , line : Int
  }

## Test suite effector object
data Suite E = 
  { name : String
  , line : Int
  , file : String
  , reportFail : TestCase -> AssertInfo ->[E] Unit
  , reportSucc : TestCase ->[E] Unit
  }

{##
  Test case effector object.
 
  Server one purpose - calls terminate test execution 
 ##}
data TestArbiter E =
  { fail : AssertInfo ->[E] Unit }

let printSuitePreamble {~__file__ : String} (line : Int) (name : String) =
  printStrLn "[====] Running test suite \{name}";
  printStrLn "[    ] from \{~__file__ | strFmt}:\{line}"

let printCaseOk (TestCase {name}) =
  printStrLn "[ \{
    Color.setFgColor Color.Green | strFmt
  }OK\{Color.resetAll | strFmt} ] \{name | strFmt}"

let printCaseFail
  {~__file__ : String}
  (TestCase {name, line})
  (AssertInfo {msg, line=assertLine}) =
    printStrLn "[\{
        Color.setFgColor Color.Red | strFmt
      }FAIL\{
        Color.resetAll | strFmt
      }] \{name | strFmt}";
    printStrLn "       In \{~__file__ | strFmt}:\{
      assertLine} assertion failed:";
    printStrLn "       \{msg | strFmt}"

let printSuiteFooter (succ : Int) (fail : Int) =
  if succ == 0 && fail == 0 then
    printStrLn "[====] No tests have been run!"
  else if succ == 1 && fail == 0 then
    printStrLn "[====] Test have passed!"
  else if succ == 2 && fail == 0 then
    printStrLn "[====] Both tests passed!"
  else if fail == 0 then
    printStrLn "[====] All \{succ} tests have passed!"
  else
    printStrLn "[====] \{succ}/\{fail + succ} tests have passed!";
  assert {msg="Test suite failed"} (fail == 0);
  printStrLn ""

parameter ~suite : Suite _
parameter ~testCase : TestCase
parameter ~testArbiter : TestArbiter _

{##
  Runs test suite.
 ##}
pub let testSuite
  {~__line__, ~__file__}
  (name : String)
  (f : {E, ~suite : Suite E} -> Unit ->[E] Unit) =
  printSuitePreamble ~__line__ name;
  handle ~suite = Suite
    { name
    , line = ~__line__
    , file = ~__file__
    , reportFail = fn tc => 
      effect assert / r =>
        printCaseFail tc assert;
        fn (succ, fail) => r () (succ, fail + 1)
    , reportSucc =
      effect tc / r =>
        printCaseOk tc;
        fn (succ, fail) => r () (succ + 1, fail) }
    return x => fn (succ, fail) => printSuiteFooter succ fail
    finally c => c (0, 0) in
  f ()

{##
  Runs single test case. Requires test suite to work.
 ##}
pub let testCase
  {~__line__, ~suite : Suite _}
  name
  (f : {E, X, ~testArbiter : TestArbiter E, ~onError : Unit ->[E] X}
    -> Unit ->[E] Unit) =
  let res = 
    handle ~testArbiter =
      TestArbiter { fail = effect assertInfo => Some assertInfo }
      return _ => None in
   (let ~onError () = ~testArbiter.fail
      (AssertInfo {msg="Uncaught ~onError call", line= ~__line__}) in 
    f ()) in
  let testCase = TestCase {line = ~__line__, name } in
  match res with
  | Some assertInfo => ~suite.reportFail testCase assertInfo
  | None            => ~suite.reportSucc testCase
  end

{##
  Asserts that given value is True.
 ##}
pub let assertTrue
  {~__line__, ~testArbiter : TestArbiter _, ?msg : String}
  cond =
    if cond then
      ()
    else
      ~testArbiter.fail
        (AssertInfo {line= ~__line__, msg = 
          msg.unwrapOr "Expected to be true"})

{##
  Asserts that given value if False
 ##}
pub let assertFalse
  {~__line__, ~testArbiter : TestArbiter _, ?msg : String}
  cond =
    assertTrue {msg=msg.unwrapOr "Expected to be false"} (not cond)

{##
  Asserts that 2 values are equal, according to first value's `equal` method.
 ##}
pub let assertEq 
  { ~__line__
  , ~testArbiter : TestArbiter _
  , ?msg : String
  , X : type
  , Y : type
  , method equal : X ->> Y ->> Bool } 
  (expected : X) (actual : Y) =
    assertTrue {msg = "Expected values to be equal"} (expected.equal actual)

{##
  Asserts that 2 values are equal, according to first value's `equal` method.
  Default error message is generated using format methods.
 ##}
pub let assertEqF
  { ~__line__
  , ~testArbiter : TestArbiter _
  , ?msg : String
  , X : type
  , Y : type
  , method format : X ->> String
  , method format : Y ->> String
  , method equal : X ->> Y ->> Bool } 
  (expected : X) (actual : Y) =
    assertTrue
      {msg = "Expected\n\t\{expected}\n\t\{actual}\nto be equal"}
      (expected.equal actual)

let callsOnError (f : {E, ~onError : _ ->[E] _} -> Unit ->[E] _) =
  handle
    ~onError = effect _ => True
    return _ => False
  in f ()

{##
  Asserts that given function will call ~onError method.
 ##}
pub let assertCallsOnError
  { ~__line__
  , ~testArbiter
  , ?msg : String }
  (f : {E, ~onError : _ ->[E] _} -> Unit ->[E] _ ) =
    assertTrue
      {msg = "Expected function to call on error implicit"}
      (callsOnError f)

{##
  Asserts that given function will not call ~onError method.
 ##}
pub let assertDoesNotCallOnError
  { ~__line__
  , ~testArbiter
  , ?msg : String }
  (f : {E, ~onError : _ ->[E] _} -> Unit ->[E] _ ) =
    assertFalse
      {msg = "Expected function to not call on error implicit"}
      (callsOnError f)

pub let runTests () = testSuite "Prelude/*" (fn () => 
  testCase "`chr` calls on error" (fn () =>
    assertCallsOnError (fn _ => chr 300));
  
  testCase "`chr` does not call on error" (fn () =>
    assertDoesNotCallOnError (fn _ => chr 127));
  
  testCase "`mkStr` count = 0" (fn _ =>
    assertEq (mkStr "abc" 0) "");
    
  testCase "`mkStr` count < 0" (fn _ =>
    assertEq (mkStr "abc" (-1)) "";
    assertEq (mkStr "abc" (-10)) "");
  
  testCase "`mkStr` count > 0" (fn _ =>
    assertEq (mkStr "abc" 1) "abc";
    assertEq (mkStr "abc" 2) "abcabc";
    assertEq (mkStr "abc" 3) "abcabcabc";
    assertEq (mkStr "abc" 5) "abcabcabcabcabc");
  ())
