{# This file is part of DBL, released under MIT license.
   See LICENSE for details.
 #}

import open AnsiTerminal
import open Mutable

{# ========================================================================= #}
{# Testing data types #}

data ErrorType = | Assertion | Expectation

## Information about assertion fail in test
data ErrorInfo =
  { msg : String
  , line : Int
  , file : String
  , errorType : ErrorType
  }

{# TODO : Add tags to tests and suites #}

data TestCase =
  { name : String
  , line : Int
  , file : String
  , body : Unit ->[IO] List ErrorInfo
  }

abstr data rec TestSuite =
  { name   : String
  , line   : Int
  , file   : String
  , suites : Ref IO (List TestSuite)
  , tests  : Ref IO (List TestCase)
  }

{# ========================================================================= #}
{# Helper functions #}

{# This module is to be used in other parts of standard library,
    so some functionality is reimplemented #}
let listRev xs =
  let rec aux acc xs =
    match xs with
    | [] => acc
    | x :: xs => aux (x :: acc) xs
    end
  in aux [] xs

let rec listFold f acc xs =
  match xs with
  | [] => acc
  | x :: xs => listFold f (f acc x)  xs
  end

let rec listIter f xs =
  match xs with
  | [] => ()
  | x :: xs => f x; listIter f xs
  end

{# ========================================================================= #}
{# Printing functions #}

# TODO delete when improved format methods are introduced
let strFmt = () #StringFmt {escape=False}
method format {?fmt : Unit} (self : String) = self

let warn (msg : String) =
  printStrLn "\{Color.setFgColor Color.Yellow | strFmt
    }[WARNING] \{ msg | strFmt }\{ Color.resetAll | strFmt }"

method format (et : ErrorType) =
  match et with
  | Assertion   => "assertion"
  | Expectation => "expectation"
  end

{# Printing for Tests #}
let printErrorInfo (ErrorInfo { msg, line, file, errorType }) =
  printStrLn "  <>  In \{ file | strFmt }:\{ line } \{ errorType } failed:";
  printStrLn "       \{ msg | strFmt}"

method printTestSuccess (TestCase { name, line, file }) =
  printStr   "[ \{ Color.setFgColor Color.Green | strFmt }OK";
  printStr   "\{Color.resetAll | strFmt} ]";
  printStrLn " \"\{ name | strFmt}\" from \{ file | strFmt }:\{ line | strFmt }"

method printTestFailure (TestCase { name, line, file }) assertInfos =
  printStr   "[\{ Color.setFgColor Color.Red | strFmt }FAIL";
  printStr   "\{ Color.resetAll | strFmt }]";
  printStrLn " \"\{ name | strFmt }\" from \{ file | strFmt }:\{ line }";
  listIter printErrorInfo (listRev assertInfos)

{# Printing for suites #}
method printTestsPreamble (TestSuite {file, line, name}) (prefix : String) =
  printStrLn "[====] Running test suite [\{prefix}]/\{name}";
  printStrLn "[    ] from \{file | strFmt}:\{line}"

method printSuitesPreamble (TestSuite {file, line, name}) (prefix : String) =
  printStrLn "[====] Running subsuites of [\{prefix}]/\{name}";
  printStrLn ""

method reportNoTests (TestSuite { name }) =
  printStrLn "[====] Suite \{name} has no tests"

method reportNoSubsuites (TestSuite { name }) =
  ## printStrLn "[====] Suite \"\{name}\" has no subsuites";
  printStrLn ""

let printTestsResult (testResults : Pair Int Int) =
  let (succ, fail) = testResults in
  if succ == 0 && fail == 0 then
    printStrLn "[====] No tests have been run"
  else if succ == 1 && fail == 0 then
    printStrLn "[====] A test have passed!"
  else if succ == 2 && fail == 0 then
    printStrLn "[====] Both tests passed!"
  else if fail == 0 then
    printStrLn "[====] All \{succ} tests have passed"
  else
    printStrLn "[====] \{succ}/\{fail + succ} tests have passed";
  (fail == 0)

method printSubSuitesResult (TestSuite { name }) (prefix : String)
    (subsuiteResults : Pair Int Int) =
  let (succ, fail) = subsuiteResults in
  if succ == 0 && fail == 0 then (
    printStr "[====] No subsuites of [\{ prefix | strFmt }]";
    printStr "/\{ name | strFmt } have been run")
  else if succ == 1 && fail == 0 then (
    printStr "[====] A subsuite of [\{ prefix | strFmt }]";
    printStr "/\{ name | strFmt } have passed!")
  else if succ == 2 && fail == 0 then (
    printStr "[====] Both subsuites of [\{ prefix | strFmt }]";
    printStr "/\{ name | strFmt } passed!")
  else if fail == 0 then (
    printStr "[====] All \{succ} subsuites of [\{ prefix | strFmt }]";
    printStr "/\{ name | strFmt } have passed")
  else
    printStr "[====] \{succ}/\{fail + succ} subsuites of [\{
      prefix | strFmt }]/\{ name | strFmt } have passed";
  printStrLn "";
  printStrLn "";
  (fail == 0)

{# ========================================================================= #}
{# Running Test Logic #}

{##
  Test case effector object.
  Provides two functionalities:
  - allows for reporting assertion failure, which ends test immediately
  - allows for reporting expectation failure, which allows for the test
    to continue, but at the end test fails anyway.
##}
data TestArbiter E =
  { abort : {X} -> ErrorInfo ->[E] X
  , fail  : ErrorInfo ->[E] Unit
  }

{# TODO : Rewrite to use tail-recurrsion #}
let testArbiterHandler =
  handler TestArbiter
    { abort = effect assertInfo => [ assertInfo ]
    , fail  = effect assertInfo => assertInfo :: resume ()
    }
    return _ => []
  end

{##
  Runs the test
  Returns True if the test passed, False otherwise
##}
method runTest (tc : TestCase) =
  match tc.body() with
  | []     =>
    tc.printTestSuccess;
    True
  | errors =>
    tc.printTestFailure errors;
    False
  end

let evalTest (succ, fail) (tc : TestCase) =
  if tc.runTest then (1+succ, fail) else (succ, 1+fail)

rec
  {##
    Runs Tests associated with suite,
    then runs sub-suite
    Returns True if all tests and sub-suite passed, False otherwise
  ##}
  method runSuite (suite : TestSuite) prefix =
    let allTestsPassed =
      match listRev suite.tests.get with
      | []    => suite.reportNoTests; True
      | tests =>
        suite.printTestsPreamble prefix;
        let testResults = listFold evalTest (0, 0) tests in
        printTestsResult testResults
      end
    let subsuitesPassed =
      match listRev suite.suites.get with
      | []     => suite.reportNoSubsuites; True
      | suites =>
        suite.printSuitesPreamble prefix;
        let suiteResults =
          listFold (evalSuite (prefix + "/" + suite.name)) (0,0) suites in
        suite.printSubSuitesResult prefix suiteResults
      end
    in allTestsPassed && subsuitesPassed


  let evalSuite prefix (succ, fail) (suite : TestSuite) =
    if suite.runSuite prefix then
      (succ+1, fail)
    else
      (succ, fail+1)
end

{# ========================================================================= #}
{# MainTestRunner #}

data MainTestRunner = { suites : Ref IO (List TestSuite) }

let mainTestRunner = MainTestRunner { suites = ioMut.ref [] }

method runAllTests (MainTestRunner{ suites }) =
  let (_, fail) = listFold (evalSuite "") (0, 0) (listRev suites.get) in
  if fail == 0 then ()
  {# TODO : Change this to normal print + exit #}
  else runtimeError "[====] Test Environment Failed"

{##
  If this file is imported, all registered tests will be run after program
  finishes
##}
handle _ = ()
  return _ =>
    {# TODO : Implement some sort of argument parsing,
              and tests-to-run selection #}
    {# TODO : When attributes are implemented, add them here #}
    let _ = mainTestRunner.runAllTests in ()
  finally _ => ()

method addTest (TestSuite { tests }) tc =
  tests := tc :: tests.get

method addSuite (MainTestRunner { suites }) suite =
  suites := suite :: suites.get

method addSuite (TestSuite { suites }) suite =
  suites := suite :: suites.get

{# ========================================================================= #}
{# Registering tests #}

{## This function wraps test body, handling test arbiter effect ##}
let constructTest name line file
    (f : {E, ~testArbiter : TestArbiter E} ->
      Unit ->[E, IO] Unit) =
  let body () =
    handle ~testArbiter / F with testArbiterHandler
    let ~onError () = ~testArbiter.abort (ErrorInfo
      { msg="Uncaught ~onError call", line, file, errorType=Assertion })
    in
    {# TODO : Add measuring execution time #}
    f ()
  in TestCase {name, line, file, body }


pub method addTest
    {~__line__ = line, ~__file__ = file}
    (suite : TestSuite) testName
    (f : {E, ~testArbiter : TestArbiter E} ->
      Unit ->[E, IO] Unit) =
  suite.addTest (constructTest testName line file f)

pub let createTestSuite {~__line__ = line, ~__file__ = file} name =
  let suites = ioMut.ref []
  let tests = ioMut.ref []
  let suite = TestSuite { name, file, line, tests, suites } in
  mainTestRunner.addSuite suite;
  suite

pub method addSuite
    {~__line__ = line, ~__file__ = file}
    (suite : TestSuite) name =
  let suites = ioMut.ref []
  let tests = ioMut.ref [] in
  let suite' = TestSuite { name, file, line, tests, suites } in
  suite.addSuite suite';
  suite'

{# ========================================================================= #}
{# Assertion and Expectation Interface #}

{##
  Asserts that given value is True.
 ##}
pub let assertTrue
    {~__line__, ~__file__, ~testArbiter : TestArbiter _, ?msg : String}
    cond =
  if cond then
    ()
  else
    ~testArbiter.abort
      (ErrorInfo {line= ~__line__, file= ~__file__, errorType=Assertion
        , msg = msg.unwrapOr "Assertion Failed: Expected to be true"})

{##
  Asserts that given value if False
 ##}
pub let assertFalse
    {~__line__, ~__file__, ~testArbiter : TestArbiter _, ?msg : String}
    cond =
  assertTrue
    { msg=msg.unwrapOr "Assertion Failed: Expected to be false" } (not cond)

{##
  Asserts that 2 values are equal, according to first value's `equal` method.
 ##}
pub let assertEq 
    { ~__line__
    , ~__file__
    , ~testArbiter : TestArbiter _
    , ?msg : String
    , X : type
    , Y : type
    , method equal : X ->> Y ->> Bool } 
    (expected : X) (actual : Y) =
  assertTrue
    { msg = "Assertion Failed: Expected values to be equal" }
    (expected.equal actual)

{##
  Asserts that 2 values are equal, according to first value's `equal` method.
  Default error message is generated using format methods.
 ##}
pub let assertEqF
    { ~__line__
    , ~__file__
    , ~testArbiter : TestArbiter _
    , ?msg : String
    , X : type
    , Y : type
    , method format : X ->> String
    , method format : Y ->> String
    , method equal : X ->> Y ->> Bool } 
    (expected : X) (actual : Y) =
  assertTrue
    {msg =
      "Assertion Failed: Expected\n\t\{expected}\n\t\{actual}\nto be equal"}
    (expected.equal actual)

let callsOnError (f : {E, ~onError : _ ->[E] _} -> Unit ->[E] _) =
  handle
    ~onError = effect _ => True
    return _ => False
  in f ()

{##
  Asserts that given function will call ~onError method.
 ##}
pub let assertCallsOnError
    { ~__line__
    , ~__file__
    , ~testArbiter
    , ?msg : String }
    (f : {E, ~onError : _ ->[E] _} -> Unit ->[E] _ ) =
  assertTrue
    {msg = "Assertion Failed: Expected function to call on error implicit"}
    (callsOnError f)

{##
  Asserts that given function will not call ~onError method.
 ##}
pub let assertDoesNotCallOnError
    { ~__line__
    , ~__file__
    , ~testArbiter
    , ?msg : String }
    (f : {E, ~onError : _ ->[E] _} -> Unit ->[E] _ ) =
  assertFalse
    {msg = "Assertion Failed: Expected function to not call on error implicit"}
    (callsOnError f)


{##
  Expects that given value is True.
 ##}
pub let expectTrue
    {~__line__, ~__file__, ~testArbiter : TestArbiter _, ?msg : String}
    cond =
  if cond then
    ()
  else
    ~testArbiter.fail
      (ErrorInfo {line= ~__line__, file= ~__file__, errorType=Expectation
        , msg=msg.unwrapOr "Expectation Failed: Expected to be true"})

{##
  Expects that given value if False
 ##}
pub let expectFalse
    {~__line__, ~__file__, ~testArbiter : TestArbiter _, ?msg : String}
    cond =
  expectTrue
    { msg=msg.unwrapOr "Expectation Failed: Expected to be false"}
    (not cond)

{##
  Expects that 2 values are equal, according to first value's `equal` method.
 ##}
pub let expectEq 
    { ~__line__
    , ~__file__
    , ~testArbiter : TestArbiter _
    , ?msg : String
    , X : type
    , Y : type
    , method equal : X ->> Y ->> Bool } 
    (expected : X) (actual : Y) =
  expectTrue
    { msg = "Expectation Failed: Expected values to be equal"}
    (expected.equal actual)

{##
  Expects that 2 values are equal, according to first value's `equal` method.
  Default error message is generated using format methods.
 ##}
pub let expectEqF
    { ~__line__
    , ~__file__
    , ~testArbiter : TestArbiter _
    , ?msg : String
    , X : type
    , Y : type
    , method format : X ->> String
    , method format : Y ->> String
    , method equal : X ->> Y ->> Bool } 
    (expected : X) (actual : Y) =
  expectTrue
    {msg =
      "Expectation Failed: Expected\n\t\{expected}\n\t\{actual}\nto be equal"}
    (expected.equal actual)

let callsOnError (f : {E, ~onError : _ ->[E] _} -> Unit ->[E] _) =
  handle
    ~onError = effect _ => True
    return _ => False
  in f ()

{##
  Expects that given function will call ~onError method.
 ##}
pub let expectCallsOnError
    { ~__line__
    , ~__file__
    , ~testArbiter
    , ?msg : String }
    (f : {E, ~onError : _ ->[E] _} -> Unit ->[E] _ ) =
  expectTrue
    {msg = "Expectation Failed: Expected function to call on error implicit"}
    (callsOnError f)

{##
  Expects that given function will not call ~onError method.
 ##}
pub let expectDoesNotCallOnError
    { ~__line__
    , ~__file__
    , ~testArbiter
    , ?msg : String }
    (f : {E, ~onError : _ ->[E] _} -> Unit ->[E] _ ) =
  expectFalse
    {msg =
      "Expectation Failed: Expected function to not call on error implicit"}
    (callsOnError f)
