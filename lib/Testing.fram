{# This file is part of DBL, released under the MIT license.
 # See LICENSE for details.
 #}

import Map
import Mutable as M
import String as S
import List
import AnsiTerminal as T

## # Testing framework

# =============================================================================
# Helper functions

# -----------------------------------------------------------------------------
# Location

# Source code location tracker
data Loc = {file : String, line : Int}

# Position smart constructor
let mkLoc {~__line__ = line, ~__file__ = file} = Loc {line, file}

method toString (Loc {file, line}) = "\{file}:\{line}"

# -----------------------------------------------------------------------------
# Pathing

# Keeps track of namespace nesting level
data Path = {path : Option (List String)}

pub let ~suitePath = Path {path=None}

section
  parameter ~suitePath : Path
  parameter ~__modulePath__ : String

  let parseModulePath () =
    let toks = ~__modulePath__.splitOn '/' in
    match toks with
    | [] => impossible ()
    | pref :: toks' =>
      if pref == ""
        then toks'
        else toks
    end

  let getPath () =
    match ~suitePath.path with
    | Some pth => pth
    | None     => parseModulePath ()
    end

  let extendPath (name : String) =
    let pth = getPath () in
    Path {path = Some (pth + [name])}
end

# =============================================================================
# Test data structures

data TestResult = TR_Accept | TR_Reject

data LogType =
  | LT_Exit
  | LT_Fail
  | LT_Expect
  | LT_UserInfo

data LogMessage =
  { logType : LogType
  , message : String
  , loc     : Loc
  }

# Log message smart contructor
let mkLogMsg {~__line__, ~__file__} logType message =
  LogMessage {loc = mkLoc, message, logType}

data TestCase =
  { name : String
  , path : List String
  , loc  : Loc
  , body : Unit ->[] Pair TestResult (List LogMessage)
  }

data TestLogs  =
  { testCase : TestCase
  , result   : TestResult
  , logs     : List LogMessage
  }

# -----------------------------------------------------------------------------
# TestCases' effect handlers

{# Tracks state of a test case. Allows "soft" failing. #}
data TestCaseTracker E =
  { hardFail  : {X} -> Unit ->[E] X
  , softFail  : Unit ->[E] Unit
  , testExit  : {X} -> Unit ->[E] X
  }

let testCaseTrackerH =
  handler TestCaseTracker
    { effect softFail _ / r = fn _ => r () TR_Reject
    , effect hardFail _ / r = fn _ => TR_Reject
    , effect testExit _     = fn s => s
    }
    return _ => id
    finally c => c TR_Accept
  end

{# Stores all logs from a test case execution. #}
data TestLogger E = { log : LogMessage ->[E] Unit }

let testLoggerH =
  handler TestLogger
    { effect log l / r = fn logs => r () (l :: logs) }
    return s => fn logs => (s, List.rev logs)
    finally c => c ([] : List LogMessage)
  end

{#
  Test case smart constructor.
  Wraps test execution with required handlers.
#}
let mkTestCase
    {~__file__, ~__line__, ~suitePath : Path}
    (name : String)
    (f : { E_TL : effect
         , E_TT : effect
         , ~testLogger : TestLogger E_TL
         , ~testCaseTracker : TestCaseTracker E_TT
         } -> Unit ->[E_TL, E_TT] Unit) =
  let loc     = mkLoc
  let body () = 
    handle ~testLogger / E_TL with testLoggerH in
    handle ~testCaseTracker / E_TT with testCaseTrackerH in
      f {E_TL, E_TT} ()
  in
  TestCase {name, path=getPath (), loc, body}

# =============================================================================
# TestCase tree

# Organizes all registered tests into a tree structure
let Map {module SMap} = Map.make {Key=String}

type NestedCase = Pair String TestCase

data rec TestTree = {tests : List NestedCase, suites : SMap.T TestTree}
let emptyTestTree = TestTree {tests=[], suites=SMap.empty}

method addTest (tree : TestTree) (test : TestCase) =
  let TestCase {path, name} = test in
  let rec visit (TestTree {tests, suites}) path =
    match path with
    | [] => TestTree {tests = (name, test) :: tests, suites}
    | ns :: path =>
      let sub = suites.find ns >.unwrapOr emptyTestTree in
      TestTree {tests, suites = suites.add ns (visit sub path)}
    end
  in
  visit tree path

let constructTestTree (tests : List TestCase) = 
  tests.foldRight
    (fn test (tree : TestTree) => tree.addTest test)
    emptyTestTree

method iter
    (tree : TestTree)
    (f : {nesting : Int} -> Either String NestedCase ->> Unit) =
  let rec iter (tree : TestTree) (nesting : Int) =
    let nesting = nesting + 1 in
    tree.tests.iter (fn tc => f {nesting} (Right tc));
    tree.suites.iter (fn {key} suite => f {nesting} (Left key);
                                        iter suite nesting)
  in
  iter tree (-1)

# =============================================================================
# Session's effect handlers

{#
  Tracks all logs from all tests. Assigns numbers for each entry for easier
  test referring.
#}
data SessionLogger E = {reportTest : TestLogs ->[E] Int}

let sessionLoggerH =
  handler SessionLogger
    { effect reportTest log / r =
      fn (id, logs) => r id (1 + id, (id, log) :: logs)}
    return s => fn (_, logs) => (s, List.rev logs)
    finally c => c (1, [])
  end

{# Counts all failed and succeeded tests. #}
data SessionTestCounter E = {countTest : TestResult ->[E] Unit}

let sessionTestCounterH =
  handler SessionTestCounter
    { effect countTest tr / r = fn (acc, fail) =>
        match tr with
        | TR_Accept => r () (acc + 1, fail)
        | TR_Reject => r () (acc, fail + 1)
        end
    }
    return _ => id
    finally c => c (0, 0)
  end

# =============================================================================
# Pretty printing utilities

let printNesting nest =
  printStr (replicate "  " nest)

let printTreeNamespace namespace nest =
  printNesting nest;
  printStrLn namespace

let printTreeTestResult
    (name : String)
    (result : TestResult)
    (idx : Option Int)
    nest =
  printNesting nest;
  printStr 
    match result with
    | TR_Accept => "\{T.Font.setFgColor T.Font.Green}✔ "
    | TR_Reject => "\{T.Font.setFgColor T.Font.Red}✖ "
    end;
  match idx with
  | Some idx => printStr "(\{idx}) "
  | None => ()
  end;
  printStrLn "\{T.Font.resetAll}\{name}"

method toString (lt : LogType) = 
  let (col, name) =
    match lt with
    | LT_Exit     => (T.Font.Green, "EXIT")
    | LT_Fail     => (T.Font.Red,   "ASSERT")
    | LT_Expect   => (T.Font.Red,   "EXPECT")
    | LT_UserInfo => (T.Font.Blue,  "LOG")
    end
  in
  "\{T.Font.setFgColor col}\{name}\{T.Font.resetAll}"

let printLogMessage (log : LogMessage) =
  printStrLn "> \{log.logType} (\{log.loc})";
  printStrLn log.message

let printTestLogs (tl : TestLogs) (num : Int) =
  let col =
    T.Font.setFgColor
      match tl.result with
      | TR_Accept => T.Font.Green
      | TR_Reject => T.Font.Red
      end
  let preamble = "\{col}(\{num})\{T.Font.resetAll}"
  let testFullName =
    tl.testCase.path.foldRight
      (fn (s1 : String) s2 => s1 + "/" + s2)
      tl.testCase.name
  let preamble = preamble + " \{testFullName}\n\tfrom \{tl.testCase.loc}"
  in
  printStrLn preamble;
  tl.logs.iter printLogMessage;
  printStrLn ""

let printSessionPreamble () =
  printStrLn "Running all tests...";
  printStrLn ""

let printSessionLogs (logs : List (Pair Int TestLogs)) =
  if logs.length > 0 then
   (printStrLn "Session logs: ";
    printStrLn "";
    logs.iter (fn (idx, logs) => printTestLogs logs idx))

let printSessionSummary (succ : Int) (fail : Int) =
  printStrLn "\{succ}/\{succ + fail} tests passed!"

# =============================================================================
# Top level handler

# Keeps track of all registered tests.
let tests = M.ioMut.ref ([] : List TestCase)

# Additional option - enables showing logs of failed tests.
let logFailed = M.ioMut.ref True

let shouldLogResult tr =
  match tr with
  | TR_Accept => False
  | TR_Reject => logFailed.get
  end

## Adds a nested test suite.
pub let testSuite
    {~__modulePath__, ~suitePath : Path}
    (name : String)
    (f : {~suitePath : Path} -> Unit ->> Unit) =
  let ~suitePath = extendPath name in
  f ()

## Creates a test case.
pub let testCase
    {~__file__, ~__line__, ~suitePath : Path}
    name
    (f : { E_TL
        , E_TT
        , ~testLogger : TestLogger E_TL
        , ~testCaseTracker : TestCaseTracker E_TT
        } -> Unit ->[E_TL, E_TT] Unit) =
  tests := (mkTestCase name f :: tests.get)

let runTest
    { E_SL : effect
    , ~sessionLogger : SessionLogger E_SL
    , E_ST : effect
    , ~sessionTestCounter : SessionTestCounter E_ST }
    (testCase : TestCase) =
  let (result, logs) = testCase.body () in
  let logNum = 
    if shouldLogResult result then
      Some (~sessionLogger.reportTest (TestLogs {testCase, logs, result}))
    else
      None
  in
  ~sessionTestCounter.countTest result;
  (testCase.name, result, logNum)

# Test routine
let runTests () =
  printSessionPreamble ();
  let tests = tests.get.rev in
  let tree = constructTestTree tests in
  let ((succ, fail), logs) =
    handle ~sessionLogger / E_SL with sessionLoggerH in
    handle ~sessionTestCounter / E_ST with sessionTestCounterH in
      tree.iter (fn {nesting} node =>
        match node with
        | Left ns => printTreeNamespace ns nesting
        | Right (name, test) =>
          let (_, result, logNum) = runTest {E_SL, E_ST} test in
          printTreeTestResult name result logNum nesting
        end)
  in
  if tests.length > 0 then
    printStrLn "";
  printSessionLogs logs;
  printSessionSummary succ fail;
  if fail > 0 then
    exit 1
  else
    exit 0;
  ()

# Global handler. Forces test evaulation at the end of session.
handle _ = ()
  return _ => runTests ()
  finally _ => ()

# =============================================================================
# Test Case tools

section
  parameter ~testCaseTracker : TestCaseTracker _
  parameter ~testLogger : TestLogger _

  let log' {~__line__, ~__file__} lt msg = ~testLogger.log (mkLogMsg lt msg)

  let hardFail () = ~testCaseTracker.hardFail ()
  let softFail () = ~testCaseTracker.softFail ()
  let testExit () = ~testCaseTracker.testExit ()

  # ---------------------------------------------------------------------------
  # Assertions

  {##
    ## Test assertions

    Test assertions checks if given condition is true.
    If not, they terminate test execution and report
    test failure.
   ##}

  {## Asserts that given condition is true. ##}
  pub let assertTrue
      {~__line__, ~__file__, ?msg : String}
      cond =
    if not cond then
     (let message = msg.unwrapOr "Assertion Failed: Expected to be true" in
      log' LT_Fail message;
      hardFail ())

  {## Asserts that given condition is false. ##}
  pub let assertFalse
      {~__line__, ~__file__, ?msg : String}
      cond =
    assertTrue
      {msg=msg.unwrapOr "Assertion Failed: Expected to be false"} (not cond)

  {## Asserts that given values are equal. ##}
  pub let assertEq 
      { ~__line__
      , ~__file__
      , ?msg : String
      , X : type
      , Y : type
      , method equal : X ->> Y ->> Bool } 
      (expected : X) (actual : Y) =
    assertTrue
      {msg = "Assertion Failed: Expected values to be equal"}
      (expected.equal actual)

  {##
    Asserts that given values are equal.
    Uses `show` method for more elaborate logging.
   ##}
  pub let assertEqS
      { ~__line__
      , ~__file__
      , ?msg : String
      , X : type
      , Y : type
      , method show : X ->> String
      , method show : Y ->> String
      , method equal : X ->> Y ->> Bool } 
      (expected : X) (actual : Y) =
    assertTrue
      {msg =
        "Assertion Failed: Expected \{expected.show} and \{actual.show} to be equal"}
      (expected.equal actual)

  let callsOnError (f : {E, ~onError : _ ->[E,_] _} -> Unit ->> _) =
    handle
      ~onError = effect _ => True
      return _ => False
    in f ()

  {##
    Asserts that given function will call ~onError function.
    Function results are discarded.
   ##}
  pub let assertCallsOnError
      { ~__line__
      , ~__file__
      , ?msg : String }
      (f : {E, ~onError : _ ->[E,_] _} -> Unit ->> _ ) =
    assertTrue
      {msg = "Assertion Failed: Expected function to call ~onError implicit"}
      (callsOnError f)

  {##
    Asserts that given function will not call ~onError function.
   ##}
  pub let assertDoesNotCallOnError
      { ~__line__
      , ~__file__
      , ?msg : String }
      (f : {E, ~onError : _ ->[E,_] _} -> Unit ->> _ ) =
    assertFalse
      {msg =
        "Assertion Failed: Expected function to not call ~onError implicit"}
      (callsOnError f)

  # ---------------------------------------------------------------------------
  # Expectations

  {##
    # Expectations

    Expectations checks if given conditions holds. On fail, they report test
    failure, but don't terminate test execution. This enables to compose
    more elaborate test log. Test will be reported as failed, just as regular
    asserts do.
   ##}

  {## Expects given condition to be true. ##}
  pub let expectTrue
      {~__line__, ~__file__, ?msg : String}
      cond =
    if not cond then (
      let message = msg.unwrapOr "Expectation Failed: Expected to be true" in
      log' LT_Expect message;
      softFail ())

  pub let expectFalse
      {~__line__, ~__file__, ?msg : String}
      cond =
    expectTrue
      {msg=msg.unwrapOr "Expectation Failed: Expected to be false"}
      (not cond)

  {## Expects given values to be equal. ##}
  pub let expectEq 
      { ~__line__
      , ~__file__
      , ?msg : String
      , X : type
      , Y : type
      , method equal : X ->> Y ->> Bool } 
      (expected : X) (actual : Y) =
    expectTrue
      {msg = "Expectation Failed: Expected values to be equal"}
      (expected.equal actual)

  {##
    Expects given values to be equal.
    Uses `show` method for better error printing.
   ##}
  pub let expectEqS
      { ~__line__
      , ~__file__
      , ?msg : String
      , X : type
      , Y : type
      , method show : X ->> String
      , method show : Y ->> String
      , method equal : X ->> Y ->> Bool } 
      (expected : X) (actual : Y) =
    expectTrue
      {msg =
        "Expectation Failed: Expected: \{expected.show} and \{actual.show} to be equal"}
      (expected.equal actual)

  {##
    Expects given function to call ~onError function.
   ##}
  pub let expectCallsOnError
      { ~__line__
      , ~__file__
      , ?msg : String }
      (f : {E, ~onError : _ ->[E,_] _} -> Unit ->> _) =
    expectTrue
      {msg = "Expectation Failed: Expected function to call ~onError implicit"}
      (callsOnError f)

  {##
    Expects that given function will not call ~onError function.
   ##}
  pub let expectDoesNotCallOnError
      { ~__line__
      , ~__file__
      , ?msg : String }
      (f : {E, ~onError : _ ->[E,_] _} -> Unit ->> _) =
    expectFalse
      {msg =
        "Expectation Failed: Expected function to not call ~onError implicit"}
      (callsOnError f)

  # ---------------------------------------------------------------------------
  ## ## Other utilities

  ## Logs user message.
  pub let log {~__file__, ~__line__} = log' LT_UserInfo

  {##
    Terminates test early with status it's currently in.
   ##}
  pub let testExit {~__file__, ~__line__, ?msg : String} () =
    log' LT_Exit (msg.unwrapOr "Test terminated early.");
    testExit ()
end
