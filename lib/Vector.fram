## ## Vector library
{# 
This file is part of DBL, released under MIT license.
See LICENSE for details.
#}

import open Mutable
import open /Base/Bool
import open /List

abstr data Vector E T = Vector of
  { content   : Ref E (Array E T)
  , size      : Ref E Int
  , capacity  : Ref E Int
  , mut       : Mut E
  }

parameter E
parameter T

# Helper methods for vector implementation
method getContentAt (Vector {content} : Vector E T) (n : Int) =
  content.get.get n

method setContentAt (Vector {content} : Vector E T) (n : Int) (x : T) =
  content.get.at n := x
  
method setContent (Vector {content} : Vector E T) newContent =
  content := newContent

method mut (Vector {mut} : Vector E T) = mut

let getSmallestUpperPow2 (n : Int) =
  let n = n-1 in
  let n = n ||| (n>>1) in
  let n = n ||| (n>>2) in
  let n = n ||| (n>>4) in
  let n = n ||| (n>>8) in
  let n = n ||| (n>>16) in
  let n = n ||| (n>>32) in
  let n = n ||| (n>>64) in
  n+1

{## Creates vector of given size. ##}
pub let makeVector {T, ~mut : Mut E} (size : Int) =
  let capacity = (getSmallestUpperPow2 size) in
  Vector
  { content    = ~mut.ref (~mut.makeArray capacity ((extern dbl_magic : Int -> T) 0))
  , size       = ~mut.ref size
  , capacity   = ~mut.ref capacity
  , mut        = ~mut
  }

{## Returns vector of given size. ##}
pub method capacity (Vector {capacity} : Vector E T) = capacity.get

method setCapacity (Vector {capacity} : Vector E T) (n : Int) = capacity := n

{## Returns the number of elements. ##}
pub method size (Vector {size} : Vector E T) = size.get

method setSize (Vector {size} : Vector E T) (n : Int) = size := n 

{## Returns true if the vector is empty. ##}
pub method empty (Vector {size} : Vector E T) = size.get == 0

{##
  Resizes the vector to contain n elements.
  If n is smaller than the current size, the vector is truncated.
  If n is greater than size, the vector is expanded.
  If n exceeds the current capacity, the vector reallocates its storage.
##}
pub method resize {T} (self : Vector E T) (n : Int) =
  self.setSize n;
  let newCapacity = getSmallestUpperPow2 n in
  if newCapacity <= self.capacity then ()
  else (
    let newContent = self.mut.initArray newCapacity (fn i =>
      if i < self.capacity then self.getContentAt i
      else ((extern dbl_magic : Int -> T) 0)) in
    self.setContent newContent;
    self.setCapacity newCapacity
  )

{## Get the nth element of a vector. ##}
pub method get (self : Vector E T) (n : Int) =
  assert {msg="Index out of range"} (n >= 0 && n < self.size);
  self.getContentAt n

{## Set the nth element of a vector. ##}
pub method set (self : Vector E T) (n : Int) (x : T) =
  assert {msg="Index out of range"} (n >= 0 && n < self.size);
  self.setContentAt n x

{## Access the first element. ##}
pub method front (self : Vector E T) = self.get 0

{## Access the last element. ##}
pub method back (self : Vector E T) = self.get (self.size - 1)

{## Add element at the end. ##}
pub method pushBack (self : Vector E T) (x : T) =
  let newSize = self.size + 1 in
  if newSize >= self.capacity then
    self.resize newSize
  else
    self.setSize newSize;
  self.set (newSize - 1) x

{## Removes the last element. ##}
pub method popBack (self : Vector E T) =
  assert {msg="Vector is empty"} (self.empty.neg);
  self.setSize (self.size - 1)

{## Converts a list into a vector. ##}
pub let fromList {~mut : Mut E} (l : List T) =
  let vec = makeVector {T=T} l.length in
  let rec aux (n : Int) acc =
    match acc with
    | []      => vec
    | x :: xs =>
      vec.set n x;
      aux (n + 1) xs
    end
  in aux 0 l

{## Converts a vector into a list. ##}
pub method toList (self : Vector E T) =
  let rec aux (n : Int) acc =
    if n < 0 then acc
    else aux (n - 1) (self.get n :: acc)
  in aux (self.size - 1) []

{## Clears the vector. ##}
pub method clear (self : Vector E T) =
  self.setSize 0;
  self.setCapacity 0;
  self.setContent (self.mut.makeArray 0 ((extern dbl_magic : Int -> T) 0))
  