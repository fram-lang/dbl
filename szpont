open SyntaxNode;;

let u = {pos = Position.nowhere; data= Lang.Surface.ENum 5};;


{ SyntaxNode.data = Lang.Surface.EUnit; pos = Position.nowhere} |> TypeInference.Main.tr_program;;


({ SyntaxNode.data = Lang.Surface.DReplExpr ({SyntaxNode.data = Lang.Surface.ENum 2; pos = Position.nowhere}); pos = Position.nowhere});;

{SyntaxNode.data = Lang.Surface.ERepl ([[({ SyntaxNode.data = Lang.Surface.DReplExpr ({SyntaxNode.data = Lang.Surface.ENum 2; pos = Position.nowhere}); pos = Position.nowhere})]] |> List.to_seq); pos = Position.nowhere};;

{SyntaxNode.data = Lang.Surface.ERepl ([[({ SyntaxNode.data = Lang.Surface.DReplExpr ({SyntaxNode.data = Lang.Surface.ENum 2; pos = Position.nowhere}); pos = Position.nowhere})]] |> List.to_seq); pos = Position.nowhere} |> TypeInference.Main.tr_program;;


utop # {SyntaxNode.data = Lang.Surface.ERepl ([[({ SyntaxNode.data = Lang.Surface.DReplExpr ({SyntaxNode.data = Lang.Surface.ENum 2; pos = Position.nowhere}); pos = Position.nowhere})]] |> List.to_seq); pos = Position.nowhere} |> TypeInference.Main.tr_program |> (fun x -> match x.data with | Lang.Unif.ERepl (c,d) -> c | _ -> failwith "!") |> (fun x -> x ());;


- : Lang.Unif.program =
{Lang.Unif.pos =
  {Position.pos_fname = "<nowhere>"; pos_start_line = 1; pos_start_cnum = 0;
   pos_start_bol = 0; pos_length = 0; pos_end_line = 1; pos_end_bol = 1};
 pp = <abstr>;
 data =
  Lang.Unif.EReplExpr
   {Lang.Unif.body =
     {Lang.Unif.pos =
       {Position.pos_fname = "<nowhere>"; pos_start_line = 1;
        pos_start_cnum = 0; pos_start_bol = 0; pos_length = 0;
        pos_end_line = 1; pos_end_bol = 1};
      pp = <abstr>; data = Lang.Unif.ENum 2};
    to_str =
     {Lang.Unif.pos =
       {Position.pos_fname = "<nowhere>"; pos_start_line = 1;
        pos_start_cnum = 0; pos_start_bol = 0; pos_length = 0;
        pos_end_line = 1; pos_end_bol = 1};
      pp = <abstr>; data = Lang.Unif.EExtern ("dbl_defaultShow", <abstr>)};
    rest =
     {Lang.Unif.pos =
       {Position.pos_fname = "<nowhere>"; pos_start_line = 1;
        pos_start_cnum = 0; pos_start_bol = 0; pos_length = 0;
        pos_end_line = 1; pos_end_bol = 1};
      pp = <abstr>; data = Lang.Unif.ERepl (<fun>, <abstr>)}}}



TypeInference.Expr.infer_expr_type TypeInference.Env.initial;;
- : tcfix:TypeInference.TypeCheckFix.tcfix ->
    TypeInference.Common.S.program ->
    BiDirectional.infer TypeInference.TypeCheckFix.expr_result
= <fun>


module rec TCFix : TCFix = struct
  let infer_expr_type ?app_type env e =
    Expr.infer_expr_type ~tcfix:(module TCFix) ?app_type env e

  let check_expr_type env e tp =
    Expr.check_expr_type ~tcfix:(module TCFix) env e tp

  let check_def env def tp_req cont =
    Def.check_def ~tcfix:(module TCFix) env def tp_req cont

  let check_defs env defs tp_req cont =
    Def.check_defs ~tcfix:(module TCFix) env defs tp_req cont
end;;


let my_prog = {SyntaxNode.data = Lang.Surface.ERepl ([[({ SyntaxNode.data = Lang.Surface.DReplExpr ({SyntaxNode.data = Lang.Surface.ENum 2; pos = Position.nowhere}); pos = Position.nowhere})]] |> List.to_seq); pos = Position.nowhere} ;;

TypeInference.Expr.infer_expr_type ~tcfix:TCFix TypeInference.Env.initial my_prog ;;
//prawie!


module B = TCFix;;


B.infer_expr_type initial my_prog;;


B.infer_expr_type initial my_prog |> expr_result_type;;
let ty = B.infer_expr_type initial my_prog |> expr_result_type;;


# Lang.Unif.Type.view;;
- : typ -> Type.type_view = <fun>

Lang.Unif.Type.view ty;;


let prog = {SyntaxNode.data = Lang.Surface.ERepl ([[({ SyntaxNode.data = Lang.Surface.DReplExpr ({SyntaxNode.data = Lang.Surface.ENum 2; pos = Position.nowhere}); pos = Position.nowhere})]] |> List.to_seq); pos = Position.nowhere} ;;

let prog = {SyntaxNode.data = Lang.Surface.ENum 2; pos = Position.nowhere} ;;
B.infer_expr_type initial prog |> expr_result_type |> Lang.Unif.Type.view;;


Pretty.pp_type (Pretty.empty_context ()) (PPTree.empty);;


let ty = B.infer_expr_type initial prog |> expr_result_type;;
Pretty.pp_type (Pretty.empty_context ()) (PPTree.empty) ty;;
- : string = "#?T"


$ grep -R "DReplExpr"
TypeInference/RecDefs.ml:  | DReplExpr _ ->
TypeInference/Def.ml:  | DReplExpr e ->
Lang/Surface.ml:  | DReplExpr of expr
DblParser/Main.ml:    let def = make_nowhere (Lang.Surface.DReplExpr(Desugar.tr_expr e)) in
DblParser/Main.ml:    let def = make_nowhere (Lang.Surface.DReplExpr(Desugar.tr_expr e)) in

(*---------------------------*)
let unif_program = ({Lang.Unif.pos =  Position.nowhere; pp = PPTree.empty; data = Lang.Unif.ENum 2} : Lang.Unif.expr);;
