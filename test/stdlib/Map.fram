import open Testing
import /Map

let (Map { module IntMap  }) = Map.make { Key = Int }
let (Map { module StrMap  }) = Map.make { Key = String }
let (Map { module IntMap2 }) =
  Map.make { Key = Int, method lt = fn x y => x > y }

let _ =
testSuite "isEmpty" (fn _ =>
  testCase "true" (fn _ =>
    assertTrue (IntMap.empty {Val=Bool} >.isEmpty));
  
  testCase "false" (fn _ =>
    assertFalse (IntMap.singleton 13 "A" >.isEmpty)));

testSuite "size" (fn _ =>
  testCase "empty" (fn _ =>
    assertEq (IntMap.empty {Val=Int}  >.size) 0);
  
  testCase "not empty" (fn _ =>
    assertEq (IntMap.singleton 42 True >.size) 1));

testCase "randomized test" (fn _ =>
  handle
    rand = effect () => fn seed =>
      let seed = (seed * 39989 + 7) % 65536 in
      resume (seed >> 12) seed
    return x => fn _ => x
    finally c => c 0
  
  let doExtraTest (map : IntMap.T Int) (bitSet : Int) (bitMap : Int) =
    assertEq (map.fold (fn _ acc => acc + 1) 0) map.size;
    let rest = map.fold
      (fn {key} v bitSet =>
        let bit = 1 << key in
        assertTrue ((bitSet &&& bit) != 0);
        assertEq v (key + (bitMap &&& bit));
        # check if the order is ascending
        assertEq (bitSet ^^^ bit) (bitSet &&& (bitSet - 1));
        bitSet ^^^ bit)
      bitSet
    in
    assertEq rest 0

  let rec randTest (map : IntMap.T _) (bitSet : Int) (bitMap : Int) (n : Int) =
    if n == 0 then ()
    else (
      let op  = rand () in
      if op == 0 then doExtraTest map bitSet bitMap;
      let key = rand ()
      let bit = 1 << key
      in
      if (bitSet &&& bit) == 0 then (
        assertFalse (map.mem key);
        assertEq (map.find key >.unwrapOr (-1)) (-1);
        assertEq (map.findErr {~onError = fn () => -1} key) (-1))
      else (
        assertTrue (map.mem key);
        assertEq (map.find key >.unwrapOr (-1)) (key + (bitMap &&& bit));
        assertEq (map.findErr {~onError = fn () => -1} key)
          (key + (bitMap &&& bit)));
      if op < 8 then (
        let v = if op < 4 then 0 else bit
        let map = map.add key (key + v)
        let bitSet = bitSet ||| bit
        let bitMap = bitMap ^^^ (bitMap &&& bit) ^^^ v
        in
        assertTrue (map.mem key);
        assertEq (map.find key >.unwrapOr (-1)) (key + v);
        assertEq (map.findErr {~onError = fn () => -1} key) (key + v);
        randTest map bitSet bitMap (n - 1))
      else (
        let map = map.remove key
        let bitSet = bitSet ^^^ (bitSet &&& bit)
        in
        assertFalse (map.mem key);
        assertEq (map.find key >.unwrapOr (-1)) (-1);
        assertEq (map.findErr {~onError = fn () => -1} key) (-1);
        randTest map bitSet bitMap (n - 1))
    )
    in
    randTest IntMap.empty 0 0 1000)
