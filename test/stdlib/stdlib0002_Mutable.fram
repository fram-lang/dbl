import open Mutable

# Backtracking for testing
data BT E = { flip : Unit ->[E] Bool }

let hBT =
  handler BT { flip = effect () / (r : _ ->[_] List _) => r True + r False }
    return x => [x]
    finally l => l.toConstArray
  end

# ioMut and Ref
let x = ioMut.ref 0
let y = ioMut.ref 1
let _ =
  assert (x.get == 0);
  assert (y.get == 1);
  x := 2;
  assert (x.get == 2);
  assert (y.get == 1);
  y := 5;
  assert (x.get == 2);
  assert (y.get == 5)

# hMut
let ensurePure (f : _ ->[] _) = f ()
let _ = ensurePure (fn () =>
  hMut (fn mut =>
    let x = mut.ref 13 in
    assert (x.get == 13);
    x.set 42;
    assert (x.get == 42)))

# Array
let arr1 = ioMut.pureInitArray 4 id
let _ =
  assert (arr1.length == 4);
  assert (arr1.get 0 == 0);
  assert (arr1.get 1 == 1);
  assert (arr1.get 2 == 2);
  assert (arr1.get 3 == 3);
  arr1.at 2 := 13;
  assert (arr1.get 0 == 0);
  assert (arr1.get 2 == 13);
  let arr2 = arr1.clone in
  assert (arr2.length == 4);
  arr2.at 1 := 42;
  assert (arr2.get 1 == 42);
  assert (arr1.get 1 == 1);
  ()

let tab =
  handle bt with hBT in
  ioMut.initArray 2 (fn _ => bt.flip ())
let _ =
  assert (tab.length == 4);
  assert (tab.get 0 >.get 0);
  assert (tab.get 0 >.get 1);
  assert (tab.get 1 >.get 0);
  assert (not (tab.get 1 >.get 1));
  assert (not (tab.get 2 >.get 0));
  ()

# ConstArray
let _ =
  let v = arr1.get 1
  let carr = arr1.freeze in
  assert (carr.get 1 == v);
  arr1.at 1 := v + 1;
  assert (carr.get 1 == v);
  ()

# Example program
let primes n =
  {# In order to use mutability, we need a `Mut` capability. There is a
    predefined `ioMut` capability, but using it performs the `IO` effect.
    Mutability can be handled locally, by introducing a local capability,
    but the computation that uses it must be pure, as in this example. #}
  hMutArray (fn mut =>
    {# New mutable entities are created by calling methods on the `Mut`
      capability. #}
    let arr = mut.makeArray n 2
    let lastPrime = mut.ref 1
    let isPrime k =
      {# The whole computation must be pure, but it can use other effects
        locally. #}
      handle ret = effect b => b
        return () => False
      let checkPrime (p : Int) =
        if p * p > k then ret True
        else if k % p == 0 then ret False
      in
      arr.iter checkPrime
    let rec nextPrime () =
      {# Mutable entities can be accessed by the `get` method, #}
      let p = lastPrime.get + 1 in
      {# or modified using the `:=` operator. #}
      lastPrime := p;
      if isPrime p then p
      else nextPrime ()
    in
    arr.iteri (fn i _ =>
      {# To modify an array, we also use the `:=` operator, but on a special
        write-only element that can be obtained with the `at` method. To read
        an array, we use the `get` method. #}
      arr.at i := nextPrime ());
    arr)

let ptab = primes 10
let _ =
  assert (ptab.get 0 == 2);
  assert (ptab.get 1 == 3);
  assert (ptab.get 2 == 5);
  assert (ptab.get 3 == 7);
  assert (ptab.get 4 == 11);
  assert (ptab.get 5 == 13);
  assert (ptab.get 6 == 17);
  assert (ptab.get 7 == 19);
  assert (ptab.get 8 == 23);
  assert (ptab.get 9 == 29);
  ()

let _ =
  let ca = [1,2,3,4].toConstArray in
  let testarr = [1,2].toArray {~mut=ioMut} in
  let testarr2 = [3,4].toArray {~mut=ioMut} in
  let lst = ca.toList in
  let lst2 = testarr.toList in
  testarr.mapInPlace (fn x => x+1);
  let testarr3 = testarr.concat testarr2 in
  let testarr4 = testarr2.reverse in

  assert(lst.hdErr {~onError=(fn ()=> 2)} == 1);
  assert(lst2.hdErr {~onError=(fn ()=> 2)} == 1);
  assert((testarr.get 0)==2);
  assert((testarr3.get 2)==3);
  assert((testarr2.foldLeft (fn a x => a-x) 0)==(-7));
  assert((testarr2.foldRight(fn x a => a-x) 0)==(-7));
  assert((testarr.exists (fn x => x==2))==True);
  assert((testarr.forall (fn x => x==2))==False);
  assert((testarr.forall (fn x => x>0))==True);
  assert((ca.exists (fn x => x>3 ))==True);
  assert((ca.forall (fn x => x<5))==True);
  assert((ca.exists (fn x => x<0))==False);
  assert((ca.forall (fn x => x>1))==False);
  assert((testarr4.get 0)==4);
  assert((testarr4.get 1)==3);
  assert((testarr3.foldLeft (fn a x => a+x) 0)==12);
  ()

let _ =
  let arr0 = [4, 5, 6].toArray {~mut=ioMut} in
  let ca2 = arr0.freeze in
  let arr1 = arr0.map (fn x=> x+1) in
  let ca3 = ca2.map (fn x=> x+1) in
  
  assert((ca2.foldLeft (fn a x => a-x) 0)==(-15));
  assert((ca2.foldRight (fn x a => a-x) 0)==(-15));
  assert((arr1.foldLeft (fn a x => a-x) 0)== (-18));
  assert((ca3.foldLeft (fn a x => a-x) 0)== (-18));
  ()

